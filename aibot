import time
import math
import hmac
import hashlib
import logging
from datetime import datetime

import requests
from pybit.unified_trading import HTTP  # Уверете се, че pybit е инсталирана: pip install pybit

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Импортираме библиотеките за машинно обучение и AI модел
# Забележка: Тези библиотеки трябва да бъдат инсталирани преди да се използват
# pip install scikit-learn pandas numpy

class AIPredictor:
    """
    Клас, който имплементира AI базирани модели за прогнозиране на пазарните движения.
    Комбинира правила и машинно обучение за по-точни прогнози.
    Поддържа мулти-таймфрейм анализ (4ч, 1ч, 15мин, 5мин).
    """

    def __init__(self):
        self.features = {}  # Запазва предварително изчислените features по символи
        self.last_predictions = {}  # Пази последните предсказания по символи
        self.trade_history = []  # История на сделките за обучение
        self.ml_models = {}  # Машинно обучаеми модели по символи

        # Инициализиране на модел за машинно обучение
        self.initialize_ml_models()

    def initialize_ml_models(self):
        """Инициализира моделите за машинно обучение с поддръжка на incremental learning."""
        try:
            from sklearn.linear_model import SGDClassifier
            from sklearn.ensemble import HistGradientBoostingClassifier, GradientBoostingClassifier
            from sklearn.preprocessing import StandardScaler
            from sklearn.feature_selection import SelectKBest, f_classif

            # Използваме HistGradientBoostingClassifier за по-добра работа с неструктурирани данни
            # и по-добра стабилност при малки данни
            self.default_model = {
                'classifier': HistGradientBoostingClassifier(
                    max_iter=100,
                    learning_rate=0.1,
                    max_depth=5,
                    min_samples_leaf=5,
                    l2_regularization=0.1,
                    class_weight='balanced'
                ),
                'scaler': StandardScaler(),
                'selector': SelectKBest(score_func=f_classif, k=10),  # Избира 10-те най-значими индикатора
                'trained': False,
                'validation_score': 0.0,
                'feature_importance': None,
                'selected_features_idx': None
            }

            # Запазваме SGDClassifier като алтернативен модел за сравнение и backup
            self.alternative_model = {
                'classifier': SGDClassifier(loss='log_loss', penalty='l2', alpha=0.0001, 
                                           warm_start=True, max_iter=1000, tol=1e-3,
                                           class_weight='balanced'),
                'scaler': StandardScaler(),
                'trained': False,
                'validation_score': 0.0,
                'feature_importance': None
            }

            # Опционално - поддържаме и secondary модел за сравнение
            self.secondary_model = {
                'classifier': GradientBoostingClassifier(n_estimators=50, learning_rate=0.1, max_depth=3),
                'scaler': StandardScaler(),
                'trained': False,
                'validation_score': 0.0,
                'feature_importance': None
            }

            logging.info("Инициализирани ML модели с HistGradientBoostingClassifier и feature selection успешно.")
        except ImportError as e:
            logging.warning(f"Не могат да се инициализират ML модели: {e}")
            self.default_model = None
            self.secondary_model = None

    def generate_features(self, symbol, candles, trades):
        """
        Генерира features за модела от данните на свещите и сделките.

        Args:
            symbol (str): Символът за търговия
            candles (list): Масив с данни за свещите
            trades (list): Масив с данни за сделките

        Returns:
            dict: Речник с генерираните features
        """
        features = {}

        if not candles or len(candles) < 20:
            return None

        # Извличаме цените от свещите
        closes = []
        highs = []
        lows = []
        volumes = []
        opens = []

        for c in candles:
            if isinstance(c, list) and len(c) >= 6:  # v5 API format
                opens.append(float(c[1]))   # open is at index 1
                closes.append(float(c[4]))  # close is at index 4
                highs.append(float(c[2]))   # high is at index 2
                lows.append(float(c[3]))    # low is at index 3
                volumes.append(float(c[5])) # volume is at index 5
            elif isinstance(c, dict) and 'close' in c:  # old format
                opens.append(float(c.get('open', 0)))
                closes.append(float(c['close']))
                highs.append(float(c.get('high', 0)))
                lows.append(float(c.get('low', 0)))
                volumes.append(float(c.get('volume', 0)))

        if not closes:
            return None

        # Z-score анализ за откриване на аномалии
        try:
            import numpy as np
            from scipy import stats

            # Изчисляваме Z-score за последните цени (за откриване на аномалии)
            window_size = min(20, len(closes))
            if window_size >= 5:  # Минимум 5 стойности за статистически значим Z-score
                # Изчисляваме Z-score за последните няколко цени
                recent_closes = np.array(closes[-window_size:])
                rolling_mean = np.mean(recent_closes)
                rolling_std = np.std(recent_closes)

                if rolling_std > 0:
                    # Изчисляваме Z-score за последната цена
                    last_z_score = (closes[-1] - rolling_mean) / rolling_std

                    # Z-score за движение на цената (разликата между последните две цени)
                    if len(closes) >= 2:
                        price_change = closes[-1] - closes[-2]
                        price_changes = np.array([closes[i] - closes[i-1] for i in range(1, window_size)])
                        mean_change = np.mean(price_changes)
                        std_change = np.std(price_changes)

                        if std_change > 0:
                            change_z_score = (price_change - mean_change) / std_change
                            features['price_change_z_score'] = change_z_score
                        else:
                            features['price_change_z_score'] = 0
                    else:
                        features['price_change_z_score'] = 0

                    # Добавяме Z-score като feature
                    features['z_score'] = last_z_score

                    # Индикатор за екстремна стойност (абсолютна стойност на Z-score > 2)
                    features['is_extreme'] = 1 if abs(last_z_score) > 2 else 0

                    # Разделяме екстремуми на положителни/отрицателни
                    features['is_positive_extreme'] = 1 if last_z_score > 2 else 0
                    features['is_negative_extreme'] = 1 if last_z_score < -2 else 0
                else:
                    features['z_score'] = 0
                    features['price_change_z_score'] = 0
                    features['is_extreme'] = 0
                    features['is_positive_extreme'] = 0
                    features['is_negative_extreme'] = 0
            else:
                features['z_score'] = 0
                features['price_change_z_score'] = 0
                features['is_extreme'] = 0
                features['is_positive_extreme'] = 0
                features['is_negative_extreme'] = 0

            # Mean Reversion анализ
            if window_size >= 10:
                # Анализираме автокорелация за mean reversion поведение
                # Отрицателна автокорелация намеква за mean reversion (смяна на посоката)
                price_changes = [closes[i] - closes[i-1] for i in range(1, len(closes))]

                if len(price_changes) >= 10:
                    # Изчисляваме lag-1 автокорелация
                    lag1_autocorr = np.corrcoef(price_changes[:-1], price_changes[1:])[0, 1]
                    features['autocorrelation'] = lag1_autocorr

                    # Индикатор за mean reversion (отрицателна автокорелация)
                    features['mean_reversion_signal'] = 1 if lag1_autocorr < -0.2 else 0

                    # Изчисляваме дистанцията от средната стойност спрямо стандартното отклонение
                    rolling_window = min(30, len(closes))
                    rolling_mean = np.mean(closes[-rolling_window:])
                    distance_from_mean = (closes[-1] - rolling_mean) / rolling_std if rolling_std > 0 else 0
                    features['distance_from_mean'] = distance_from_mean

                    # Mean Reversion buy/sell сигнали
                    # Когато цената е много под средната и автокорелацията е отрицателна -> потенциален обрат нагоре
                    features['mean_reversion_buy'] = 1 if distance_from_mean < -1.5 and lag1_autocorr < -0.2 else 0

                    # Когато цената е много над средната и автокорелацията е отрицателна -> потенциален обрат надолу
                    features['mean_reversion_sell'] = 1 if distance_from_mean > 1.5 and lag1_autocorr < -0.2 else 0
                else:
                    features['autocorrelation'] = 0
                    features['mean_reversion_signal'] = 0
                    features['distance_from_mean'] = 0
                    features['mean_reversion_buy'] = 0
                    features['mean_reversion_sell'] = 0
            else:
                features['autocorrelation'] = 0
                features['mean_reversion_signal'] = 0
                features['distance_from_mean'] = 0
                features['mean_reversion_buy'] = 0
                features['mean_reversion_sell'] = 0

        except ImportError:
            # Ако scipy не е инсталирана, пропускаме Z-score анализа
            features['z_score'] = 0
            features['price_change_z_score'] = 0
            features['is_extreme'] = 0
            features['is_positive_extreme'] = 0
            features['is_negative_extreme'] = 0
            features['autocorrelation'] = 0
            features['mean_reversion_signal'] = 0
            features['distance_from_mean'] = 0
            features['mean_reversion_buy'] = 0
            features['mean_reversion_sell'] = 0
        except Exception as e:
            logging.error(f"Грешка при Z-score анализа: {e}")
            features['z_score'] = 0
            features['price_change_z_score'] = 0
            features['is_extreme'] = 0
            features['is_positive_extreme'] = 0
            features['is_negative_extreme'] = 0
            features['autocorrelation'] = 0
            features['mean_reversion_signal'] = 0
            features['distance_from_mean'] = 0
            features['mean_reversion_buy'] = 0
            features['mean_reversion_sell'] = 0

        # Изчисляваме базови технически индикатори

        # 1. Процентна промяна в цената за последните N периода
        for n in [1, 3, 5, 10]:
            if len(closes) > n:
                features[f'close_change_{n}'] = (closes[-1] - closes[-n-1]) / closes[-n-1] if closes[-n-1] > 0 else 0
            else:
                features[f'close_change_{n}'] = 0

        # 2. Променлива за волатилност: ATR като процент от цената
        atr = 0
        if len(highs) > 14 and len(lows) > 14 and len(closes) > 14:
            true_ranges = []
            true_ranges.append(highs[0] - lows[0])

            for i in range(1, min(14, len(highs))):
                tr1 = highs[i] - lows[i]
                tr2 = abs(highs[i] - closes[i-1])
                tr3 = abs(lows[i] - closes[i-1])
                true_ranges.append(max(tr1, tr2, tr3))

            atr = sum(true_ranges) / len(true_ranges)
            features['atr_pct'] = atr / closes[-1] if closes[-1] > 0 else 0
        else:
            features['atr_pct'] = 0

        # 3. Относителни силови индекси (RSI)
        if len(closes) >= 15:
            gains = []
            losses = []

            for i in range(1, min(15, len(closes))):
                change = closes[i] - closes[i-1]
                if change > 0:
                    gains.append(change)
                    losses.append(0)
                else:
                    gains.append(0)
                    losses.append(abs(change))

            avg_gain = sum(gains) / len(gains) if gains else 0
            avg_loss = sum(losses) / len(losses) if losses else 0

            rs = avg_gain / avg_loss if avg_loss > 0 else 0
            features['rsi'] = 100 - (100 / (1 + rs)) if rs > 0 else 0
        else:
            features['rsi'] = 50  # Неутрална стойност

        # 4. Moving Averages и позиция спрямо тях
        ma20 = sum(closes[-20:]) / 20 if len(closes) >= 20 else closes[-1]
        ma50 = sum(closes[-50:]) / 50 if len(closes) >= 50 else closes[-1]

        features['price_vs_ma20'] = closes[-1] / ma20 - 1 if ma20 > 0 else 0
        features['price_vs_ma50'] = closes[-1] / ma50 - 1 if ma50 > 0 else 0
        features['ma20_vs_ma50'] = ma20 / ma50 - 1 if ma50 > 0 else 0

        # 5. Обем и активност
        if len(volumes) > 5:
            avg_recent_volume = sum(volumes[-3:]) / 3
            avg_earlier_volume = sum(volumes[-8:-3]) / 5 if len(volumes) >= 8 else sum(volumes[:-3]) / len(volumes[:-3]) if volumes[:-3] else 1
            features['volume_change'] = avg_recent_volume / avg_earlier_volume - 1 if avg_earlier_volume > 0 else 0
        else:
            features['volume_change'] = 0

        # 6. MACD (Moving Average Convergence Divergence) индикатор
        if len(closes) >= 26:
            # Изчисляваме бързата 12-периодна EMA
            ema12 = self.calculate_ema(closes, 12)
            # Изчисляваме бавната 26-периодна EMA
            ema26 = self.calculate_ema(closes, 26)
            # MACD линия = EMA(12) - EMA(26)
            macd_line = ema12 - ema26 if (ema12 is not None and ema26 is not None) else 0

            # Изчисляваме MACD сигнална линия (9-периодна EMA на MACD линията)
            if len(closes) >= 35:  # Необходими са поне 26+9 периода
                # Създаваме масив с MACD стойности
                macd_values = []
                for i in range(26, len(closes)):
                    fast_ema = self.calculate_ema(closes[:i+1], 12)
                    slow_ema = self.calculate_ema(closes[:i+1], 26)
                    macd_values.append(fast_ema - slow_ema)

                # Изчисляваме сигналната линия като 9-периодна EMA на MACD
                signal_line = self.calculate_ema(macd_values, 9) if len(macd_values) >= 9 else macd_values[-1]

                # MACD хистограма = MACD линия - сигнална линия
                macd_hist = macd_line - signal_line

                # Добавяме MACD компонентите като features
                features['macd_line'] = macd_line
                features['macd_signal'] = signal_line
                features['macd_hist'] = macd_hist

                # Дали MACD линията е над сигналната (потенциален бичи сигнал)
                features['macd_above_signal'] = 1 if macd_line > signal_line else 0

                # Дали MACD линията наскоро е пресякла сигналната отдолу нагоре
                if len(macd_values) >= 10 and len(macd_values) >= 10:
                    prev_macd = macd_values[-2]
                    prev_signal = self.calculate_ema(macd_values[:-1], 9) if len(macd_values) >= 10 else prev_macd

                    # Бичи кръстоска (MACD преминава над сигналната линия)
                    features['macd_bullish_cross'] = 1 if (macd_line > signal_line and prev_macd < prev_signal) else 0

                    # Мечи кръстоска (MACD преминава под сигналната линия)
                    features['macd_bearish_cross'] = 1 if (macd_line < signal_line and prev_macd > prev_signal) else 0
                else:
                    features['macd_bullish_cross'] = 0
                    features['macd_bearish_cross'] = 0
            else:
                features['macd_line'] = macd_line
                features['macd_signal'] = macd_line  # При липса на данни, сигналната линия = MACD линия
                features['macd_hist'] = 0
                features['macd_above_signal'] = 0
                features['macd_bullish_cross'] = 0
                features['macd_bearish_cross'] = 0
        else:
            features['macd_line'] = 0
            features['macd_signal'] = 0
            features['macd_hist'] = 0
            features['macd_above_signal'] = 0
            features['macd_bullish_cross'] = 0
            features['macd_bearish_cross'] = 0

        # 7. Ако имаме данни за сделките, добавяме order flow метрики
        if trades and len(trades) > 10:
            buy_vol = 0
            sell_vol = 0

            for trade in trades[-100:]:  # Последните 100 сделки
                try:
                    qty = float(trade.get('size', 0))
                except:
                    qty = float(trade.get('qty', 0))  # Fallback
                side = trade.get('side', '')
                if side.lower() == 'buy':
                    buy_vol += qty
                elif side.lower() == 'sell':
                    sell_vol += qty

            total_vol = buy_vol + sell_vol
            features['buy_sell_ratio'] = (buy_vol - sell_vol) / total_vol if total_vol > 0 else 0
        else:
            features['buy_sell_ratio'] = 0

        # 8. Bollinger Bands (20-периодни с 2 стандартни отклонения)
        if len(closes) >= 20:
            # Изчисляваме 20-периодната SMA (средна)
            bb_sma = sum(closes[-20:]) / 20

            # Изчисляваме стандартното отклонение за 20 периода
            variance = sum([(price - bb_sma) ** 2 for price in closes[-20:]]) / 20
            std_dev = variance ** 0.5

            # Изчисляваме горна и долна лента (2 * стандартно отклонение)
            bb_upper = bb_sma + (2 * std_dev)
            bb_lower = bb_sma - (2 * std_dev)

            # Изчисляваме ширината на лентите като % от средната цена (мярка за волатилност)
            bb_width = (bb_upper - bb_lower) / bb_sma if bb_sma > 0 else 0

            # Определяме местоположението на цената в лентите (от 0 до 1, където 0 = долна лента, 1 = горна лента)
            if bb_upper - bb_lower > 0:
                bb_position = (closes[-1] - bb_lower) / (bb_upper - bb_lower)
            else:
                bb_position = 0.5

            # Добавяме Bollinger Bands данни към features
            features['bb_upper'] = bb_upper
            features['bb_lower'] = bb_lower
            features['bb_width'] = bb_width
            features['bb_position'] = bb_position

            # Проверка за пробив на лентите (потенциални сигнали)
            features['price_above_upper_band'] = 1 if closes[-1] > bb_upper else 0
            features['price_below_lower_band'] = 1 if closes[-1] < bb_lower else 0

            # Отчитаме свиването на лентите - индикация за ниска волатилност и предстоящо рязко движение
            if len(closes) >= 40:  # Сравняваме с предишния период
                prev_bb_width = (sum([(price - sum(closes[-40:-20]) / 20) ** 2 for price in closes[-40:-20]]) / 20) ** 0.5 * 2 * 2 / (sum(closes[-40:-20]) / 20)
                features['bb_narrowing'] = 1 if bb_width < prev_bb_width * 0.8 else 0  # Свиване с поне 20%
                features['bb_expanding'] = 1 if bb_width > prev_bb_width * 1.2 else 0  # Разширяване с поне 20%
            else:
                features['bb_narrowing'] = 0
                features['bb_expanding'] = 0
        else:
            # Ако няма достатъчно данни за изчисляване
            features['bb_upper'] = closes[-1] * 1.02 if closes else 0
            features['bb_lower'] = closes[-1] * 0.98 if closes else 0
            features['bb_width'] = 0.04
            features['bb_position'] = 0.5
            features['price_above_upper_band'] = 0
            features['price_below_lower_band'] = 0
            features['bb_narrowing'] = 0
            features['bb_expanding'] = 0

        # 9. Fibonacci нива за определяне на ключови нива на подкрепа и съпротива
        if len(highs) >= 10 and len(lows) >= 10:
            # Намираме най-високата и най-ниската точка в последните N свещи
            look_back = 20 if len(highs) >= 20 else len(highs)
            recent_high = max(highs[-look_back:])
            recent_low = min(lows[-look_back:])
            price_range = recent_high - recent_low

            if price_range > 0:
                # Изчисляваме Fibonacci нива (обръщане)
                fib_0 = recent_low  # 0% ниво
                fib_236 = recent_low + price_range * 0.236  # 23.6% ниво
                fib_382 = recent_low + price_range * 0.382  # 38.2% ниво
                fib_500 = recent_low + price_range * 0.5    # 50% ниво
                fib_618 = recent_low + price_range * 0.618  # 61.8% ниво
                fib_786 = recent_low + price_range * 0.786  # 78.6% ниво
                fib_1 = recent_high  # 100% ниво

                # Определяме текущата цена спрямо Fibonacci нивата
                current_price = closes[-1]

                # Намираме най-близките Fibonacci нива под и над текущата цена
                fib_levels = [fib_0, fib_236, fib_382, fib_500, fib_618, fib_786, fib_1]
                fib_below = max([f for f in fib_levels if f <= current_price], default=fib_0)
                fib_above = min([f for f in fib_levels if f >= current_price], default=fib_1)

                # Изчисляваме разстоянието до най-близките нива като % от текущата цена
                distance_to_support = (current_price - fib_below) / current_price if current_price > 0 else 0
                distance_to_resistance = (fib_above - current_price) / current_price if current_price > 0 else 0

                # Определяме в коя Fibonacci зона се намира цената
                fib_zone = 0
                if current_price <= fib_236:
                    fib_zone = 1  # Под 23.6%
                elif current_price <= fib_382:
                    fib_zone = 2  # Между 23.6% и 38.2%
                elif current_price <= fib_500:
                    fib_zone = 3  # Между 38.2% и 50%
                elif current_price <= fib_618:
                    fib_zone = 4  # Между 50% и 61.8%
                elif current_price <= fib_786:
                    fib_zone = 5  # Между 61.8% и 78.6%
                else:
                    fib_zone = 6  # Над 78.6%

                # Добавяме Fibonacci данни към features
                features['fib_zone'] = fib_zone
                features['fib_distance_to_support'] = distance_to_support
                features['fib_distance_to_resistance'] = distance_to_resistance

                # Проверка за отблъскване от ключово Fibonacci ниво
                # Считаме за отблъскване, ако цената се е приближила до 1% от ниво и после се е отдалечила
                recent_lows = lows[-3:]
                recent_highs = highs[-3:]

                min_recent_low = min(recent_lows)
                max_recent_high = max(recent_highs)

                # Отблъскване от подкрепа
                support_levels = [fib_0, fib_236, fib_382, fib_500]
                for level in support_levels:
                    if abs(min_recent_low - level) / level < 0.01 and closes[-1] > level * 1.005:
                        features['fib_bounce_from_support'] = 1
                        break
                else:
                    features['fib_bounce_from_support'] = 0

                # Отблъскване от съпротива
                resistance_levels = [fib_500, fib_618, fib_786, fib_1]
                for level in resistance_levels:
                    if abs(max_recent_high - level) / level < 0.01 and closes[-1] < level * 0.995:
                        features['fib_bounce_from_resistance'] = 1
                        break
                else:
                    features['fib_bounce_from_resistance'] = 0
            else:
                # По подразбиране при недостатъчен ценови диапазон
                features['fib_zone'] = 3
                features['fib_distance_to_support'] = 0.02
                features['fib_distance_to_resistance'] = 0.02
                features['fib_bounce_from_support'] = 0
                features['fib_bounce_from_resistance'] = 0
        else:
            # Ако няма достатъчно данни за изчисляване
            features['fib_zone'] = 3  # Неутрална зона
            features['fib_distance_to_support'] = 0.02
            features['fib_distance_to_resistance'] = 0.02
            features['fib_bounce_from_support'] = 0
            features['fib_bounce_from_resistance'] = 0

        # 10. Stochastic Oscillator за потвърждаване на кръстосвания при свръхпродадени/свръхкупени нива
        if len(highs) >= 14 and len(lows) >= 14 and len(closes) >= 14:
            # Период за Stochastic (14 периода е стандартно)
            period = 14

            # %K линия (бърза Stochastic линия)
            latest_close = closes[-1]
            lowest_low = min(lows[-period:])
            highest_high = max(highs[-period:])

            if highest_high - lowest_low > 0:
                stoch_k = 100 * (latest_close - lowest_low) / (highest_high - lowest_low)
            else:
                stoch_k = 50  # Неутрална стойност при липса на диапазон

            # %D линия (бавна Stochastic линия) - 3-периодна SMA на %K
            stoch_k_values = []
            for i in range(3):
                if len(closes) > period + i:
                    idx = -(i+1)
                    c = closes[idx]
                    l = min(lows[-(period+i):-i] if i > 0 else lows[-period:])
                    h = max(highs[-(period+i):-i] if i > 0 else highs[-period:])
                    if h - l > 0:
                        stoch_k_values.append(100 * (c - l) / (h - l))
                    else:
                        stoch_k_values.append(50)

            stoch_d = sum(stoch_k_values) / len(stoch_k_values) if stoch_k_values else stoch_k

            # Overbought и oversold състояния
            stoch_overbought = stoch_k > 80
            stoch_oversold = stoch_k < 20

            # Кръстоски
            stoch_bullish_cross = False
            stoch_bearish_cross = False

            # Проверяваме за кръстоски, ако имаме достатъчно данни
            if len(closes) >= period + 3:
                # Изчисляваме предишните стойности на %K и %D
                prev_k_values = []
                for i in range(1, 4):  # За предишната свещ
                    if len(closes) > period + i + 1:
                        idx = -(i+2)  # +1 защото искаме предишната свещ
                        c = closes[idx]
                        l = min(lows[-(period+i+1):-(i+1)] if i > 0 else lows[-(period+1):-1])
                        h = max(highs[-(period+i+1):-(i+1)] if i > 0 else highs[-(period+1):-1])
                        if h - l > 0:
                            prev_k_values.append(100 * (c - l) / (h - l))
                        else:
                            prev_k_values.append(50)

                prev_c = closes[-2]
                prev_l = min(lows[-(period+1):-1])
                prev_h = max(highs[-(period+1):-1])

                if prev_h - prev_l > 0:
                    prev_k = 100 * (prev_c - prev_l) / (prev_h - prev_l)
                else:
                    prev_k = 50

                prev_d = sum(prev_k_values) / len(prev_k_values) if prev_k_values else prev_k

                # Определяме кръстоски
                stoch_bullish_cross = stoch_k > stoch_d and prev_k <= prev_d
                stoch_bearish_cross = stoch_k < stoch_d and prev_k >= prev_d

            # Добавяме Stochastic данни към features
            features['stoch_k'] = stoch_k
            features['stoch_d'] = stoch_d
            features['stoch_overbought'] = 1 if stoch_overbought else 0
            features['stoch_oversold'] = 1 if stoch_oversold else 0
            features['stoch_bullish_cross'] = 1 if stoch_bullish_cross else 0
            features['stoch_bearish_cross'] = 1 if stoch_bearish_cross else 0

            # Добавяме допълнителни сигнали за Stochastic
            # Бичи сигнал: %K пресича %D отдолу нагоре в oversold зона (под 20)
            features['stoch_bullish_oversold_cross'] = 1 if stoch_bullish_cross and stoch_k < 20 else 0

            # Мечи сигнал: %K пресича %D отгоре надолу в overbought зона (над 80)
            features['stoch_bearish_overbought_cross'] = 1 if stoch_bearish_cross and stoch_k > 80 else 0
        else:
            # Ако няма достатъчно данни
            features['stoch_k'] = 50
            features['stoch_d'] = 50
            features['stoch_overbought'] = 0
            features['stoch_oversold'] = 0
            features['stoch_bullish_cross'] = 0
            features['stoch_bearish_cross'] = 0
            features['stoch_bullish_oversold_cross'] = 0
            features['stoch_bearish_overbought_cross'] = 0

        # Запазваме features и връщаме резултат
        self.features[symbol] = features
        return features

    def calculate_ema(self, prices, period):
        """
        Изчислява Exponential Moving Average (EMA).

        Args:
            prices (list): Списък с цените
            period (int): Период за изчисление на EMA

        Returns:
            float: Изчислената EMA стойност
        """
        if len(prices) < period:
            return None

        import numpy as np
        prices_array = np.array(prices)

        # Изчисляваме първата стойност като SMA
        sma = np.mean(prices_array[:period])

        # Ако имаме само точно периода, връщаме SMA
        if len(prices) == period:
            return sma

        # Тегло за EMA
        multiplier = 2 / (period + 1)

        # Векторизирано изчисление на EMA
        ema = np.zeros_like(prices_array, dtype=float)
        ema[:period] = sma

        for i in range(period, len(prices_array)):
            ema[i] = (prices_array[i] - ema[i-1]) * multiplier + ema[i-1]

        return ema[-1]

    def record_trade_result(self, symbol, features, signal, outcome, profit_pct):
        """
        Записва резултатите от сделка за използване в обучението на ML модела.

        Args:
            symbol (str): Символът за търговия
            features (dict): Използваните features за сигнала
            signal (str): Генерираният сигнал ('Buy' или 'Sell')
            outcome (str): Резултат от сделката ('TP', 'SL')
            profit_pct (float): Процент печалба/загуба
        """
        if not features:
            return

        # Преобразуваме features от dict към плосък списък за ML модела
        feature_list = self.prepare_features_for_ml(features)

        # Определяме успеха на сигнала (1 = успех, 0 = неуспех)
        success = 1 if (outcome == 'TP' or profit_pct > 0) else 0

        # Определяме посоката (1 = нагоре/Buy, 0 = надолу/Sell)
        direction = 1 if signal == 'Buy' else 0

        # Записваме данните за обучение
        trade_data = {
            'symbol': symbol,
            'features': feature_list,
            'signal': direction,
            'outcome': success,
            'profit_pct': profit_pct,
            'timestamp': datetime.now()
        }

        self.trade_history.append(trade_data)

        # Добавяме лог за броя записани сделки
        logging.info(f"Добавена сделка за {symbol} в ML историята. Общ брой: {len(self.trade_history)}")

        # Периодично обучаваме модела при натрупване на достатъчно данни
        if len(self.trade_history) >= 5:  # Намаляме прага до 5 сделки за по-бързо обучение
            self.train_ml_model()

    def prepare_features_for_ml(self, features):
        """Преобразува речника с features в плосък списък за ML модела."""
        # Подбираме ключовите features и ги нормализираме
        selected_features = []

        # Основни технически индикатори
        for key in ['rsi', 'price_vs_ma20', 'price_vs_ma50', 'ma20_vs_ma50', 
                    'atr_pct', 'macd_line', 'macd_signal', 'macd_hist',
                    'volume_change', 'buy_sell_ratio']:
            selected_features.append(features.get(key, 0))

        # Bollinger Bands
        for key in ['bb_position', 'bb_width']:
            selected_features.append(features.get(key, 0))

        # Включваме бинарни features
        for key in ['price_above_upper_band', 'price_below_lower_band', 
                    'macd_bullish_cross', 'macd_bearish_cross',
                    'stoch_overbought', 'stoch_oversold',
                    'stoch_bullish_cross', 'stoch_bearish_cross']:
            selected_features.append(1 if features.get(key, 0) == 1 else 0)

        # Добавяме Z-score и Mean Reversion features
        for key in ['z_score', 'price_change_z_score', 'is_extreme', 
                    'is_positive_extreme', 'is_negative_extreme',
                    'autocorrelation', 'distance_from_mean', 
                    'mean_reversion_signal', 'mean_reversion_buy', 'mean_reversion_sell']:
            selected_features.append(features.get(key, 0))

        return selected_features

    def train_ml_model(self):
        """Обучава ML модела от натрупаната история на сделките с поддръжка на incremental learning."""
        if not self.trade_history:
            logging.warning("Няма история на сделки за обучение на модела.")
            return

        # Изискваме само 3 сделки за начално обучение (намалено от 5)
        if len(self.trade_history) < 3:
            logging.info(f"Недостатъчно сделки за обучение ({len(self.trade_history)}/3). Изчакваме още данни.")
            return  # Нужни са поне 3 сделки за начално обучение

        try:
            import numpy as np
            from sklearn.ensemble import GradientBoostingClassifier
            from sklearn.linear_model import SGDClassifier
            from sklearn.preprocessing import StandardScaler
            from sklearn.model_selection import train_test_split
            from sklearn.metrics import accuracy_score
            
            # Групираме данните по символи за обучение на отделни модели
            symbol_data = {}
            
            for trade in self.trade_history:
                symbol = trade['symbol']
                if symbol not in symbol_data:
                    symbol_data[symbol] = {
                        'features': [],
                        'targets': []
                    }
                
                symbol_data[symbol]['features'].append(trade['features'])
                symbol_data[symbol]['targets'].append(trade['outcome'])
            
            # Обучаваме модел за всеки символ, независимо от броя сделки (без минимум от 15)
            for symbol, data in symbol_data.items():
                X = np.array(data['features'])
                y = np.array(data['targets'])
                
                # Създаваме модела, ако не съществува
                if symbol not in self.ml_models:
                    # Използваме SGDClassifier за incrementally learning
                    self.ml_models[symbol] = {
                        'classifier': SGDClassifier(loss='log_loss', penalty='l2', alpha=0.0001, 
                                                    warm_start=True, max_iter=1000, tol=1e-3),
                        'scaler': StandardScaler(),
                        'trained': False,
                        'feature_importance': None,
                        'validation_score': 0.0
                    }
                
                # Правим train-test split за валидация на модела
                test_size = min(0.2, 1/len(X)) if len(X) > 5 else 0.0
                
                if test_size > 0:
                    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=42)
                else:
                    X_train, X_test, y_train, y_test = X, None, y, None
                
                # Нормализираме данните
                X_train_scaled = self.ml_models[symbol]['scaler'].fit_transform(X_train)
                
                # Прилагаме feature selection ако имаме selector
                if 'selector' in self.ml_models[symbol]:
                    # Избираме най-значимите features
                    X_train_selected = self.ml_models[symbol]['selector'].fit_transform(X_train_scaled, y_train)
                    
                    # Запазваме индексите на избраните features за по-късно използване
                    self.ml_models[symbol]['selected_features_idx'] = self.ml_models[symbol]['selector'].get_support(indices=True)
                    
                    # Запазваме scores на features за анализ
                    if hasattr(self.ml_models[symbol]['selector'], 'scores_'):
                        feature_scores = self.ml_models[symbol]['selector'].scores_
                        logging.info(f"Feature scores за {symbol}: {feature_scores}")
                        
                        # Извеждаме най-добрите features
                        if len(feature_scores) > 0:
                            best_features_idx = np.argsort(feature_scores)[-5:]
                            best_scores = feature_scores[best_features_idx]
                            logging.info(f"Топ 5 features за {symbol}: индекси {best_features_idx}, scores {best_scores}")
                else:
                    X_train_selected = X_train_scaled
                
                # За HistGradientBoostingClassifier използваме fit вместо partial_fit
                if isinstance(self.ml_models[symbol]['classifier'], type(self.default_model['classifier'])):
                    # Обучаваме модела с всички данни
                    self.ml_models[symbol]['classifier'].fit(X_train_selected, y_train)
                    self.ml_models[symbol]['trained'] = True
                else:
                    # За други модели като SGDClassifier, използваме partial_fit
                    unique_classes = np.unique(y_train)
                    
                    if not self.ml_models[symbol]['trained']:
                        # Първоначално обучение
                        self.ml_models[symbol]['classifier'].partial_fit(X_train_selected, y_train, classes=np.array([0, 1]))
                        self.ml_models[symbol]['trained'] = True
                    else:
                        # Incremental обучение
                        self.ml_models[symbol]['classifier'].partial_fit(X_train_selected, y_train)
                
                # Валидираме модела
                if X_test is not None:
                    X_test_scaled = self.ml_models[symbol]['scaler'].transform(X_test)
                    y_pred = self.ml_models[symbol]['classifier'].predict(X_test_scaled)
                    validation_score = accuracy_score(y_test, y_pred)
                    self.ml_models[symbol]['validation_score'] = validation_score
                    
                    # Логваме резултата
                    logging.info(f"ML модел за {symbol} валидация: {validation_score:.4f} точност, {len(X)} сделки")
                else:
                    logging.info(f"ML модел за {symbol} обновен с {len(X)} сделки (без валидация)")
                
                # Изчисляваме feature importance в зависимост от типа на модела
                try:
                    # За HistGradientBoostingClassifier
                    if hasattr(self.ml_models[symbol]['classifier'], 'feature_importances_'):
                        # Директно вземаме feature_importances_
                        feature_importance = self.ml_models[symbol]['classifier'].feature_importances_
                        
                        # Ако имаме selector, трябва да върнем важността към оригиналните features
                        if 'selected_features_idx' in self.ml_models[symbol] and self.ml_models[symbol]['selected_features_idx'] is not None:
                            # Създаваме масив с нули за всички features
                            full_importance = np.zeros(X.shape[1])
                            # Поставяме важностите на избраните features
                            full_importance[self.ml_models[symbol]['selected_features_idx']] = feature_importance
                            feature_importance = full_importance
                    # За други модели като SGDClassifier
                    elif hasattr(self.ml_models[symbol]['classifier'], 'coef_'):
                        feature_importance = np.abs(self.ml_models[symbol]['classifier'].coef_[0])
                    else:
                        # Ако моделът няма вградена feature importance
                        logging.warning(f"Моделът за {symbol} не поддържа директен достъп до feature importance.")
                        feature_importance = np.ones(X.shape[1]) / X.shape[1]  # Равномерно разпределение
                    
                    # Нормализираме feature importance
                    if np.sum(feature_importance) > 0:
                        feature_importance = feature_importance / np.sum(feature_importance)
                    
                    self.ml_models[symbol]['feature_importance'] = feature_importance
                    
                    # Намираме най-важните features
                    top_features_idx = np.argsort(feature_importance)[-5:]  # Топ 5 features
                    top_features_importance = feature_importance[top_features_idx]
                    
                    logging.info(f"Топ 5 фактора за {symbol}: индекси {top_features_idx}, значимост {top_features_importance}")
                except Exception as e:
                    logging.warning(f"Не може да се изчисли feature importance за {symbol}: {e}")
                    logging.error(traceback.format_exc())
            
            # Обучаваме общ модел с всички данни
            all_features = []
            all_targets = []
            
            for trade in self.trade_history:
                all_features.append(trade['features'])
                all_targets.append(trade['outcome'])
            
            X_all = np.array(all_features)
            y_all = np.array(all_targets)
            
            # Нормализираме данните
            if self.default_model:
                # Създаваме модела, ако не съществува правилно
                if 'classifier' not in self.default_model or not isinstance(self.default_model['classifier'], SGDClassifier):
                    self.default_model['classifier'] = SGDClassifier(loss='log_loss', penalty='l2', 
                                                                     alpha=0.0001, warm_start=True, 
                                                                     max_iter=1000, tol=1e-3)
                    self.default_model['trained'] = False
                
                # Правим train-test split за общия модел
                X_train, X_test, y_train, y_test = train_test_split(X_all, y_all, test_size=0.2, random_state=42)
                X_train_scaled = self.default_model['scaler'].fit_transform(X_train)
                
                # Използваме partial_fit за общия модел
                unique_classes = np.unique(y_train)
                
                if not self.default_model['trained']:
                    self.default_model['classifier'].partial_fit(X_train_scaled, y_train, classes=np.array([0, 1]))
                    self.default_model['trained'] = True
                else:
                    self.default_model['classifier'].partial_fit(X_train_scaled, y_train)
                
                # Валидираме общия модел
                X_test_scaled = self.default_model['scaler'].transform(X_test)
                y_pred = self.default_model['classifier'].predict(X_test_scaled)
                validation_score = accuracy_score(y_test, y_pred)
                self.default_model['validation_score'] = validation_score
                
                # Добавяме feature importance
                try:
                    feature_importance = np.abs(self.default_model['classifier'].coef_[0])
                    feature_importance = feature_importance / np.sum(feature_importance)
                    self.default_model['feature_importance'] = feature_importance
                    
                    # Намираме най-важните features за общия модел
                    top_features_idx = np.argsort(feature_importance)[-5:]  # Топ 5 features
                    top_features_importance = feature_importance[top_features_idx]
                    
                    logging.info(f"Общ модел: Топ 5 фактора: индекси {top_features_idx}, значимост {top_features_importance}")
                except Exception as e:
                    logging.warning(f"Не може да се изчисли feature importance за общия модел: {e}")
                
                logging.info(f"Общ ML модел: {validation_score:.4f} точност, {len(X_all)} сделки")
        
        except Exception as e:
            logging.error(f"Грешка при обучение на ML модела: {e}")
            import traceback
            logging.error(traceback.format_exc())

    def get_ml_prediction(self, symbol, features):
        """
        Получава предсказание от ML модела за дадения символ и features.
        Използва валидационните оценки за претегляне на предсказанията.

        Returns:
            float: Вероятност за успешна сделка (0-1)
            dict: Допълнителна информация за предсказанието (ако е налична)
        """
        try:
            import numpy as np

            # Подготвяме features за ML модела
            feature_list = self.prepare_features_for_ml(features)
            feature_array = np.array([feature_list])
            
            prediction_info = {
                'used_model': 'none',
                'confidence': 0.0,
                'validation_score': 0.0,
                'top_features': []
            }

            # Избираме модела - специфичен за символа или общия
            symbol_model_available = symbol in self.ml_models and self.ml_models[symbol]['trained']
            default_model_available = self.default_model and self.default_model.get('trained', False)
            
            # Проверяваме налични модели и техните валидационни оценки
            symbol_validation_score = self.ml_models.get(symbol, {}).get('validation_score', 0.0) if symbol_model_available else 0.0
            default_validation_score = self.default_model.get('validation_score', 0.0) if default_model_available else 0.0
            
            # Ако имаме и двата модела, използваме този с по-висока валидационна оценка
            if symbol_model_available and default_model_available:
                if symbol_validation_score >= 0.6 and symbol_validation_score >= default_validation_score:
                    model = self.ml_models[symbol]
                    prediction_info['used_model'] = f'symbol_{symbol}'
                    prediction_info['validation_score'] = symbol_validation_score
                else:
                    model = self.default_model
                    prediction_info['used_model'] = 'default'
                    prediction_info['validation_score'] = default_validation_score
            elif symbol_model_available:
                model = self.ml_models[symbol]
                prediction_info['used_model'] = f'symbol_{symbol}'
                prediction_info['validation_score'] = symbol_validation_score
            elif default_model_available:
                model = self.default_model
                prediction_info['used_model'] = 'default'
                prediction_info['validation_score'] = default_validation_score
            else:
                prediction_info['used_model'] = 'none'
                return 0.5, prediction_info  # Неутрално ако няма обучен модел
            
            # Добавяме информация за feature importance
            if 'feature_importance' in model and model['feature_importance'] is not None:
                # Намираме топ 3 features
                top_features_idx = np.argsort(model['feature_importance'])[-3:]
                top_features_values = model['feature_importance'][top_features_idx]
                
                # Добавяме ги към информацията
                prediction_info['top_features'] = [
                    {'index': int(idx), 'importance': float(val)} 
                    for idx, val in zip(top_features_idx, top_features_values)
                ]

            # Нормализираме данните
            X_scaled = model['scaler'].transform(feature_array)
            
            # Прилагаме feature selection ако имаме selector и вече сме тренирали модела
            if 'selector' in model and 'selected_features_idx' in model and model['selected_features_idx'] is not None:
                # Извличаме само избраните features използвайки запазените индекси
                X_selected = X_scaled[:, model['selected_features_idx']]
            else:
                X_selected = X_scaled

            # Получаваме вероятността за успешна сделка
            try:
                # За HistGradientBoostingClassifier и други модели с predict_proba
                if hasattr(model['classifier'], 'predict_proba'):
                    probabilities = model['classifier'].predict_proba(X_selected)[0]
                    if len(probabilities) > 1:
                        prediction = probabilities[1]
                    else:
                        prediction = 0.5
                else:
                    # Ако няма predict_proba, използваме decision_function (за SGDClassifier)
                    decision = model['classifier'].decision_function(X_selected)[0]
                    # Преобразуваме решението до вероятност чрез sigmoid
                    prediction = 1 / (1 + np.exp(-decision))
            except Exception as e:
                logging.warning(f"Грешка при предсказване с ML модел: {e}, използваме резервен метод")
                # Резервен метод - използваме директно predict
                try:
                    prediction = float(model['classifier'].predict(X_scaled)[0])
                except:
                    prediction = 0.5
            
            # Записваме confidence
            prediction_info['confidence'] = float(prediction)
            
            # Претегляме prediction спрямо валидационната оценка на модела
            # Ако моделът има ниска валидационна оценка, неговото предсказание е по-близо до 0.5
            validation_weight = prediction_info['validation_score']
            
            if validation_weight < 0.55:  # Ако валидацията е лоша (близо до случайно предсказване)
                # Пренасочваме предсказанието към 0.5 (неутрално)
                adjusted_prediction = 0.5 + (prediction - 0.5) * validation_weight
            else:
                # Запазваме предсказанието с малка корекция
                adjusted_prediction = prediction
            
            logging.debug(f"ML предсказание за {symbol}: {prediction:.4f}, коригирано: {adjusted_prediction:.4f}, " +
                         f"използван модел: {prediction_info['used_model']}, валидация: {prediction_info['validation_score']:.4f}")
            
            return adjusted_prediction, prediction_info

        except Exception as e:
            logging.error(f"Грешка при ML предсказание: {e}")
            import traceback
            logging.error(traceback.format_exc())
            return 0.5, {'used_model': 'error', 'confidence': 0.5, 'validation_score': 0.0, 'top_features': []}

    def calculate_rsi(self, prices, period=14):
        """
        Изчислява RSI (Relative Strength Index) за даден масив от цени и период.
        
        Args:
            prices (list): Списък с цени
            period (int): Период за изчисление на RSI (по подразбиране 14)
            
        Returns:
            float: Изчисленият RSI (стойност между 0 и 100)
        """
        if len(prices) < period + 1:
            return 50  # Неутрална стойност при липса на данни
        
        # Изчисляваме промените в цената
        deltas = [prices[i] - prices[i-1] for i in range(1, len(prices))]
        
        # Разделяме печалби и загуби
        gains = [delta if delta > 0 else 0 for delta in deltas]
        losses = [-delta if delta < 0 else 0 for delta in deltas]
        
        # Първоначална средна печалба и загуба
        avg_gain = sum(gains[:period]) / period
        avg_loss = sum(losses[:period]) / period
        
        # Изчисляваме RSI
        for i in range(period, len(deltas)):
            avg_gain = (avg_gain * (period - 1) + gains[i]) / period
            avg_loss = (avg_loss * (period - 1) + losses[i]) / period
        
        if avg_loss == 0:
            return 100
        
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        
        return rsi

    def predict_movement(self, symbol, features):
        """
        Прогнозира посоката на движение на цената базирано на комбинация от
        правила, мулти-таймфрейм анализ и ML модел.

        Args:
            symbol (str): Символът за търговия
            features (dict): Dictionary с изчислените features

        Returns:
            dict: Прогнозата с вероятности за нагоре/надолу и сила на сигнала
        """
        if not features:
            return {'up_probability': 0.5, 'signal_strength': 0, 'trend': 'neutral'}

        # Проста претеглена система за предсказване, която може да бъде заменена с LSTM
        up_score = 0

        # RSI компонент
        rsi = features.get('rsi', 50)
        if rsi < 30:  # Пренапродадено
            up_score += 1
        elif rsi > 70:  # Пренакупено
            up_score -= 1

        # Тренд компонент от MA
        price_vs_ma20 = features.get('price_vs_ma20', 0)
        price_vs_ma50 = features.get('price_vs_ma50', 0)
        ma20_vs_ma50 = features.get('ma20_vs_ma50', 0)

        if price_vs_ma20 > 0 and price_vs_ma50 > 0 and ma20_vs_ma50 > 0:
            up_score += 1  # Силен възходящ тренд
        elif price_vs_ma20 < 0 and price_vs_ma50 < 0 and ma20_vs_ma50 < 0:
            up_score -= 1  # Силен низходящ тренд

        # MACD компонент
        macd_line = features.get('macd_line', 0)
        macd_signal = features.get('macd_signal', 0)
        macd_hist = features.get('macd_hist', 0)
        macd_bullish_cross = features.get('macd_bullish_cross', 0)
        macd_bearish_cross = features.get('macd_bearish_cross', 0)

        # Добавяме MACD сигнали с тежест
        if macd_bullish_cross == 1:
            # Бичи сигнал: MACD линията пресича сигналната отдолу нагоре
            up_score += 2  # По-голяма тежест заради силния сигнал
        elif macd_bearish_cross == 1:
            # Мечи сигнал: MACD линията пресича сигналната отгоре надолу
            up_score -= 2  # По-голяма тежест заради силния сигнал

        # Допълнителен сигнал от MACD хистограма
        if macd_hist > 0 and macd_hist > macd_hist * 0.1:
            # Положителна и растяща хистограма (потенциално възходящ тренд)
            up_score += 1
        elif macd_hist < 0 and macd_hist < macd_hist * 0.1:
            # Отрицателна и намаляваща хистограма (потенциално низходящ тренд)
            up_score -= 1

        # Обща позиция на MACD
        if macd_line > 0 and macd_signal > 0:
            # Двете линии са положителни - позитивен тренд
            up_score += 0.5
        elif macd_line < 0 and macd_signal < 0:
            # Двете линии са отрицателни - негативен тренд
            up_score -= 0.5

        # Волатилност компонент
        atr_pct = features.get('atr_pct', 0)

        # Скорошна динамика на цената
        close_change_1 = features.get('close_change_1', 0)
        close_change_3 = features.get('close_change_3', 0)
        close_change_5 = features.get('close_change_5', 0)

        momentum_avg = (close_change_1 + close_change_3 + close_change_5) / 3

        if momentum_avg > 0.005:  # Силна положителна инерция
            up_score += 1
        elif momentum_avg < -0.005:  # Силна отрицателна инерция
            up_score -= 1

        # Order flow компонент
        buy_sell_ratio = features.get('buy_sell_ratio', 0)

        if buy_sell_ratio > 0.2:  # Силен buy bias
            up_score += 1
        elif buy_sell_ratio < -0.2:  # Силен sell bias
            up_score -= 1

        # Нови компоненти - Bollinger Bands
        bb_position = features.get('bb_position', 0.5)
        price_above_upper_band = features.get('price_above_upper_band', 0)
        price_below_lower_band = features.get('price_below_lower_band', 0)
        bb_narrowing = features.get('bb_narrowing', 0)

        # Цена под долната лента (потенциално пренапродаден актив)
        if price_below_lower_band == 1:
            up_score += 1.5  # Силен сигнал за обръщане нагоре
        # Цена над горната лента (потенциално пренакупен актив)
        elif price_above_upper_band == 1:
            up_score -= 1.5  # Силен сигнал за обръщане надолу
        # Позиция на цената в рамките на лентите
        elif bb_position < 0.2:  # Близо до долната лента
            up_score += 0.5  # Слаб сигнал за възходящ потенциал
        elif bb_position > 0.8:  # Близо до горната лента
            up_score -= 0.5  # Слаб сигнал за низходящ потенциал

        # Свиване на лентите (очаквана по-висока волатилност)
        if bb_narrowing == 1 and momentum_avg > 0:
            up_score += 0.5  # Очакваме пробив нагоре при положителна инерция
        elif bb_narrowing == 1 and momentum_avg < 0:
            up_score -= 0.5  # Очакваме пробив надолу при отрицателна инерция

        # Fibonacci нива
        fib_zone = features.get('fib_zone', 3)
        fib_bounce_from_support = features.get('fib_bounce_from_support', 0)
        fib_bounce_from_resistance = features.get('fib_bounce_from_resistance', 0)

        # Отблъскване от подкрепа (потенциален възходящ сигнал)
        if fib_bounce_from_support == 1:
            up_score += 2  # Силен сигнал за покупка

        # Отблъскване от съпротива (потенциален низходящ сигнал)
        if fib_bounce_from_resistance == 1:
            up_score -= 2  # Силен сигнал за продажба

        # Позиция спрямо Fibonacci зони
        if fib_zone <= 2:  # В ниска Fibonacci зона (под 38.2%)
            up_score += 0.5  # Предимно възходящ потенциал
        elif fib_zone >= 5:  # Във висока Fibonacci зона (над 61.8%)
            up_score -= 0.5  # Предимно низходящ потенциал

        # Stochastic Oscillator
        stoch_overbought = features.get('stoch_overbought', 0)
        stoch_oversold = features.get('stoch_oversold', 0)
        stoch_bullish_cross = features.get('stoch_bullish_cross', 0)
        stoch_bearish_cross = features.get('stoch_bearish_cross', 0)
        stoch_bullish_oversold_cross = features.get('stoch_bullish_oversold_cross', 0)
        stoch_bearish_overbought_cross = features.get('stoch_bearish_overbought_cross', 0)

        # Силен бичи сигнал: кръстоска от пренапродадена зона
        if stoch_bullish_oversold_cross == 1:
            up_score += 2.5  # Много силен сигнал за обрат нагоре
        # Силен мечи сигнал: кръстоска от пренакупена зона
        elif stoch_bearish_overbought_cross == 1:
            up_score -= 2.5  # Много силен сигнал за обрат надолу
        # Стандартни кръстоски (по-слаби сигнали)
        elif stoch_bullish_cross == 1:
            up_score += 1  # Нормален бичи сигнал
        elif stoch_bearish_cross == 1:
            up_score -= 1  # Нормален мечи сигнал
        # Пренакупена/пренапродадена зона без кръстоска
        elif stoch_oversold == 1:
            up_score += 0.5  # Слаб сигнал за възможен обрат нагоре
        elif stoch_overbought == 1:
            up_score -= 0.5  # Слаб сигнал за възможен обрат надолу

        # Комбинирани сигнали за по-голяма увереност

        # Комбинация 1: RSI + Stochastic (силен сигнал при съвпадение)
        if rsi < 30 and stoch_oversold == 1:
            up_score += 1  # Потвърждение на пренапродадено състояние
        elif rsi > 70 and stoch_overbought == 1:
            up_score -= 1  # Потвърждение на пренакупено състояние

        # Комбинация 2: MACD + Stochastic кръстоски
        if macd_bullish_cross == 1 and stoch_bullish_cross == 1:
            up_score += 1.5  # Двоен потвърден бичи сигнал
        elif macd_bearish_cross == 1 and stoch_bearish_cross == 1:
            up_score -= 1.5  # Двоен потвърден мечи сигнал

        # Комбинация 3: Bollinger Bands + Fibonacci
        if price_below_lower_band == 1 and fib_zone <= 2:
            up_score += 1  # Двойна подкрепа - от BB и Fibonacci ниво
        elif price_above_upper_band == 1 and fib_zone >= 5:
            up_score -= 1  # Двойна съпротива - от BB и Fibonacci ниво

        # Нормализиране до вероятност от правилата
        # Скала вече не е от -12 до +12, а от -15 до +15 заради добавените Z-score и Mean Reversion индикатори
        max_score = 15  # Нова максимална абсолютна стойност на скора
        rules_probability = 0.5 + (up_score / (max_score * 2))
        rules_probability = max(0.1, min(0.9, rules_probability))  # Ограничаваме в диапазон [0.1, 0.9]

        # Определяме дали посоката е нагоре/надолу според правилата
        rules_trend = 'neutral'
        if rules_probability > 0.65:
            rules_trend = 'up'
        elif rules_probability < 0.35:
            rules_trend = 'down'

        # Получаваме предсказание от ML модела ако е приложимо
        ml_prediction_result = self.get_ml_prediction(symbol, features)
        
        # Проверяваме дали новата версия връща tuple или само вероятност
        if isinstance(ml_prediction_result, tuple):
            ml_success_probability, ml_prediction_info = ml_prediction_result
        else:
            ml_success_probability = ml_prediction_result
            ml_prediction_info = {'used_model': 'unknown', 'confidence': ml_success_probability, 'validation_score': 0.0}

        # Адаптивна тежест за ML модела според неговата валидационна оценка
        ml_weight = 0.4  # Базова тежест 40%
        
        # Ако имаме валидационна оценка, коригираме тежестта
        if 'validation_score' in ml_prediction_info and ml_prediction_info['validation_score'] > 0:
            validation_score = ml_prediction_info['validation_score']
            # Увеличаваме тежестта на модела с висока валидационна оценка
            if validation_score >= 0.7:  # Много добра валидация
                ml_weight = 0.6  # 60% тежест за модела
            elif validation_score >= 0.6:  # Добра валидация
                ml_weight = 0.5  # 50% тежест
            elif validation_score < 0.55:  # Лоша валидация
                ml_weight = 0.2  # 20% тежест
        
        # Комбинираме предсказанията от правилата и ML модела с адаптивна тежест
        if self.default_model and self.default_model.get('trained', False):
            # За Buy предсказание (rules_trend == 'up'), high ML вероятност е благоприятна
            # За Sell предсказание (rules_trend == 'down'), low ML вероятност е благоприятна
            ml_direction_boost = 0

            # Проверка за несъответствие между ML и техническия анализ
            ml_confidence_signal = "up" if ml_success_probability > 0.65 else "down" if ml_success_probability < 0.35 else "neutral"
            
            # Регистрираме противоречие, ако има такова
            contradiction = (ml_confidence_signal == "up" and rules_trend == "down") or \
                          (ml_confidence_signal == "down" and rules_trend == "up")
            
            if contradiction:
                logging.warning(f"Несъответствие между ML ({ml_confidence_signal}) и технически анализ ({rules_trend}) за {symbol}.")
                # При противоречие намаляваме значително тежестта на ML модела
                ml_weight = ml_weight * 0.4  # Намаляваме до 40% от оригиналната тежест
            
            if rules_trend == 'up':
                ml_direction_boost = (ml_success_probability - 0.5) * 2  # -1 до +1
            elif rules_trend == 'down':
                ml_direction_boost = ((1 - ml_success_probability) - 0.5) * 2  # -1 до +1

            # Комбинираме двата подхода с адаптивна тежест
            combined_boost = ml_direction_boost * ml_weight  

            # Прилагаме влиянието към вероятността от правилата
            # При противоречие намаляваме влиянието
            influence_factor = 0.1 if contradiction else 0.2
            up_probability = rules_probability + combined_boost * influence_factor

            # Гарантираме, че крайната вероятност остава в разумни граници
            up_probability = max(0.1, min(0.9, up_probability))
            
            # Логваме информация за предсказанието
            logging.debug(f"ML предсказание за {symbol}: {ml_success_probability:.4f}, " +
                         f"валидация: {ml_prediction_info.get('validation_score', 0):.4f}, " + 
                         f"тежест: {ml_weight:.2f}, финална вероятност: {up_probability:.4f}")
        else:
            # Ако ML моделът не е обучен, използваме само правилата
            up_probability = rules_probability

        # Определяме силата на сигнала (0-1)
        signal_strength = abs(up_probability - 0.5) * 2  # 0 = неутрален, 1 = силен сигнал

        # Определяме финалния тренд 
        trend = 'neutral'
        if up_probability > 0.65:
            trend = 'up'
        elif up_probability < 0.35:
            trend = 'down'

        # Допълнителна информация за индикаторите в предсказването
        indicators_info = {
            'macd': {
                'macd_line': macd_line,
                'macd_signal': macd_signal,
                'macd_hist': macd_hist,
                'macd_bullish_cross': macd_bullish_cross == 1,
                'macd_bearish_cross': macd_bearish_cross == 1
            },
            'bollinger': {
                'position': bb_position,
                'above_upper': price_above_upper_band == 1,
                'below_lower': price_below_lower_band == 1,
                'narrowing': bb_narrowing == 1
            },
            'fibonacci': {
                'zone': fib_zone,
                'bounce_from_support': fib_bounce_from_support == 1,
                'bounce_from_resistance': fib_bounce_from_resistance == 1
            },
            'stochastic': {
                'overbought': stoch_overbought == 1,
                'oversold': stoch_oversold == 1,
                'bullish_cross': stoch_bullish_cross == 1,
                'bearish_cross': stoch_bearish_cross == 1,
                'bullish_oversold_cross': stoch_bullish_oversold_cross == 1,
                'bearish_overbought_cross': stoch_bearish_overbought_cross == 1
            },
            'ml_model': {
                'success_probability': ml_success_probability,
                'trained': self.default_model.get('trained', False) if self.default_model else False,
                'symbol_specific': symbol in self.ml_models and self.ml_models[symbol].get('trained', False),
                'data_points': len(self.trade_history)
            }
        }

        prediction = {
            'up_probability': up_probability,
            'signal_strength': signal_strength,
            'trend': trend,
            'indicators_info': indicators_info  # Включваме информация за всички индикатори
        }

        # Добавяме информация за мулти-таймфрейм анализа, ако е наличен
        if hasattr(self, 'analyze_multi_timeframe'):
            try:
                # Извличаме свещите за различните таймфреймове
                candles_data = {}
                timeframes = {'candles_5m', 'candles_15m', 'candles_1h', 'candles_4h'}
                
                # Проверяваме дали имаме достъп до данните от мулти-таймфрейм анализа
                all_data_available = True
                for tf in timeframes:
                    if not hasattr(self, tf) or not getattr(self, tf):
                        all_data_available = False
                
                if all_data_available:
                    mtf_result = self.analyze_multi_timeframe(symbol, {
                        'candles_5m': getattr(self, 'candles_5m'),
                        'candles_15m': getattr(self, 'candles_15m'),
                        'candles_1h': getattr(self, 'candles_1h'),
                        'candles_4h': getattr(self, 'candles_4h')
                    })
                    
                    # Добавяме информацията към предсказанието
                    prediction['multi_timeframe'] = {
                        'score': mtf_result['score'],
                        'alignment': mtf_result['alignment'],
                        'trend': mtf_result['trend'],
                        'timeframes': {}
                    }
                    
                    # Добавяме опростена информация за всеки таймфрейм
                    for tf, tf_result in mtf_result['timeframes'].items():
                        prediction['multi_timeframe']['timeframes'][tf] = {
                            'trend': tf_result['trend'],
                            'strength': tf_result['signal_strength']
                        }
            except Exception as e:
                logging.error(f"Грешка при добавяне на MTF информация: {e}")
                
        # Запазваме предсказанието
        self.last_predictions[symbol] = prediction

        return prediction


class BybitTradingBot:
    def __init__(self, api_key, api_secret, telegram_token, telegram_chat_id, risk_percent=0.05, test_mode=False):
        self.api_key = api_key
        self.api_secret = api_secret
        self.telegram_token = telegram_token
        self.telegram_chat_id = telegram_chat_id
        self.risk_percent = risk_percent
        self.test_mode = test_mode
        # Създаваме AI predictor
        self.ai_predictor = AIPredictor()
        # Bybit REST API основен URL - използваме testnet за разработка и тест
        self.base_url = "https://api-testnet.bybit.com" if test_mode else "https://api.bybit.com"
        
        # Инициализираме система за управление на rate limiting
        self.api_request_count = 0
        self.api_request_timestamp = time.time()
        self.api_request_limit = 120  # Максимален брой заявки за минута
        self.rate_limit_wait_time = 1  # Минимално време за изчакване в секунди
        
        # Речници за кеширане на данни
        self.candles_cache = {}  # Съхраняване на последните извлечени свещи
        self.trades_cache = {}   # Съхраняване на последните извлечени сделки
        self.last_cache_update = {}  # Време на последното обновяване на кеша
        self.atr_cache = {}      # Кеш за ATR стойности
        self.atr_cache_time = {} # Време на последното изчисление на ATR
        
        # Създаване на сесия за API заявките (използваме pybit за улеснение при приватните заявки)
        try:
            from pybit.unified_trading import HTTP
            if self.test_mode:
                # Use testnet in test mode
                self.session = HTTP(
                    testnet=True,
                    api_key=api_key if api_key != "your_api_key_here" else None,
                    api_secret=api_secret if api_secret != "your_api_secret_here" else None
                )
                self.base_url = "https://api-testnet.bybit.com"
                logging.info("Running in TEST MODE using Bybit testnet")
            else:
                self.session = HTTP(api_key=api_key, api_secret=api_secret)
        except Exception as e:
            logging.error("Pybit не е инсталиран или не успя да се инициализира. Инсталирайте пакета pybit.")
            raise e
            
        # Извличане на начален баланс
        self.balance = 0.0
        self.update_balance()
        logging.info(f"Initial balance: {self.balance:.2f} USDT")
        # Изтегляне на информация за всички фючърсни символи (напр. тик размери, минимални количества)
        self.symbols_info = {}
        self.all_symbols = []
        self.fetch_symbols_info()
        # Регистрируем текущите отворени позиции (за да не отваряме дублиращи се)
        self.open_positions = {}  # формат: { символ: {'side': 'Buy'/'Sell', 'entry_price': float, 'tp': float, 'sl': float} }
        
    def manage_rate_limit(self):
        """Управлява rate limiting за API заявки за избягване на блокиране."""
        current_time = time.time()
        time_diff = current_time - self.api_request_timestamp
        
        # Нулираме броячите, ако е изминала повече от минута
        if time_diff > 60:
            self.api_request_count = 0
            self.api_request_timestamp = current_time
            return
            
        # Увеличаваме брояча на заявките
        self.api_request_count += 1
        
        # Ако достигнем лимита, изчакваме
        if self.api_request_count >= self.api_request_limit:
            wait_time = max(self.rate_limit_wait_time, 60 - time_diff + 1)
            logging.warning(f"Достигнат rate limit ({self.api_request_count} заявки за {time_diff:.1f}с). Изчакване {wait_time:.1f}с...")
            time.sleep(wait_time)
            # Нулираме броячите след изчакването
            self.api_request_count = 0
            self.api_request_timestamp = time.time()

    def update_balance(self):
        """Актуализира текущия баланс (напр. USDT) от акаунта в Bybit."""
        try:
            # Управление на rate limiting
            self.manage_rate_limit()
            
            # Using the pybit session which handles authentication automatically
            response = self.session.get_wallet_balance(
                accountType="UNIFIED", 
                coin="USDT"
            )
            logging.debug(f"Balance API response: {response}")

            if response.get("retCode") == 0:
                balances = response.get("result", {}).get("list", [])
                logging.debug(f"Balance list: {balances}")

                # Първо проверяваме за availableBalance (най-важното)
                for wallet in balances:
                    total_available = wallet.get("totalAvailableBalance", "0")
                    if total_available and total_available != "":
                        try:
                            self.balance = float(total_available)
                            logging.info(f"Found total available balance: {self.balance} USDT")
                            return
                        except (ValueError, TypeError) as e:
                            logging.error(f"Error converting totalAvailableBalance '{total_available}': {e}")

                # Проверка за USDT в списъка с монети
                for wallet in balances:
                    coins = wallet.get("coin", [])
                    for coin in coins:
                        if coin.get("coin") == "USDT":
                            # Опитваме няколко различни свойства за баланса
                            for balance_field in ["availableToWithdraw", "availableBalance", "walletBalance", "equity"]:
                                balance_value = coin.get(balance_field, "0")
                                if balance_value and balance_value != "":
                                    try:
                                        value = float(balance_value)
                                        if value > 0:
                                            self.balance = value
                                            logging.info(f"Found USDT {balance_field}: {self.balance}")
                                            return
                                    except (ValueError, TypeError) as e:
                                        logging.error(f"Error converting {balance_field} '{balance_value}': {e}")

                # Ако все още нямаме баланс, проверяваме цялото портфолио
                for wallet in balances:
                    for balance_field in ["totalWalletBalance", "totalMarginBalance", "totalAvailableBalance", "totalEquity"]:
                        balance_value = wallet.get(balance_field, "0")
                        if balance_value and balance_value != "":
                            try:
                                value = float(balance_value)
                                if value > 0:
                                    self.balance = value
                                    logging.info(f"Using {balance_field} as balance: {self.balance}")
                                    return
                            except (ValueError, TypeError) as e:
                                logging.error(f"Error converting {balance_field} '{balance_value}': {e}")

                # Ако все още не сме намерили баланс, проверяваме всички монети
                if self.balance <= 0 and balances:
                    logging.warning("USDT balance not found, checking all coins")
                    for wallet in balances:
                        coins = wallet.get("coin", [])
                        for coin in coins:
                            # Handle empty string values
                            coin_name = coin.get("coin", "unknown")
                            for balance_field in ["availableToWithdraw", "availableBalance", "walletBalance", "equity"]:
                                balance_value = coin.get(balance_field, "0")
                                if balance_value and balance_value != "":
                                    try:
                                        value = float(balance_value)
                                        if value > 0:
                                            logging.info(f"Found balance in {coin_name}: {value} ({balance_field})")

                                            # Ако е USDT или базова валута, записваме я
                                            if coin_name == "USDT" or coin_name == "USD" or coin_name == "USDC":
                                                self.balance = value
                                                logging.info(f"Using {coin_name} balance: {self.balance}")
                                                return
                                    except (ValueError, TypeError):
                                        pass

            else:
                logging.warning(f"Неуспешно взимане на баланс: {response.get('retMsg')}")

            # Ако все още нямаме баланс, пробваме алтернативен подход
            if self.balance <= 0:
                try:
                    # Използваме get_account_info за получаване на баланса
                    account_info = self.session.get_account_info()
                    if account_info.get("retCode") == 0:
                        account_data = account_info.get("result", {})
                        available_balance = account_data.get("availableBalance", "0")

                        if available_balance and available_balance != "":
                            try:
                                self.balance = float(available_balance)
                                logging.info(f"Using account availableBalance: {self.balance}")
                                return
                            except (ValueError, TypeError) as e:
                                logging.error(f"Error converting account availableBalance '{available_balance}': {e}")
                except Exception as e:
                    logging.error(f"Error getting account info: {e}")

            # Ако все още нямаме баланс в реален режим, използваме малък тестов баланс
            if self.balance <= 0:
                if self.test_mode:
                    self.balance = 100.0
                    logging.info("Using sample balance of 100 USDT for test mode")
                else:
                    # В реален режим задаваме малък баланс, но показваме предупреждение
                    self.balance = 10.0 
                    logging.warning("Could not determine real balance - using minimal 10 USDT. Check API permissions.")
                    self.send_telegram("⚠️ Предупреждение: Не може да се определи реалният баланс. Използва се минимален баланс от 10 USDT. Проверете API ключовете и разрешенията им.")

        except Exception as e:
            logging.error(f"Грешка при взимане на баланс: {e}")
            # Set a minimal sample balance for testing only in test mode
            if self.test_mode:
                self.balance = 100.0
                logging.info("Using sample balance of 100 USDT for testing after error")
            else:
                # В реален режим задаваме малък баланс, но показваме предупреждение
                self.balance = 10.0
                logging.warning("Error getting balance - using minimal 10 USDT for safety")
                self.send_telegram("⚠️ Грешка при взимане на баланс: " + str(e))

    def fetch_symbols_info(self):
        """Изтегля информация за всички линейни фючърси (напр. минимален тик, минимално количество)."""
        try:
            result = self.session.get_instruments_info(category='linear')
            if result.get('retCode') == 0:
                symbols_list = result['result']['list']
                all_active_symbols = []
                
                for info in symbols_list:
                    symbol = info['symbol']
                    self.symbols_info[symbol] = info

                    # Филтриране на символи - добавяме само активни за търговия
                    # 1. Символът трябва да е активен за търговия
                    if info.get('status') != 'Trading':
                        continue
                        
                    # Добавяме в списъка с активни символи
                    all_active_symbols.append(symbol)

                logging.info(f"Fetched info for {len(symbols_list)} symbols, found {len(all_active_symbols)} active symbols.")
                
                # Вторичен филтър за обем и волатилност
                self.filter_symbols_by_liquidity(all_active_symbols)
            else:
                logging.error(f"Неуспешно взимане на символи: {result.get('retMsg')}")
        except Exception as e:
            logging.error(f"Изключение при взимане на символи: {e}")
            
    def filter_symbols_by_liquidity(self, active_symbols):
        """Филтрира символите по обем и волатилност за откриване на активни пазари."""
        logging.info("Филтриране на символи по обем и волатилност...")
        
        # Настройки за минимален обем и волатилност
        min_volume_24h = 500000   # Намален минимален 24-часов обем (500K USDT)
        min_atr_pct = 0.3        # Намален минимален ATR като процент (0.3%)
        
        filtered_symbols = []
        
        # Проверяваме всеки активен символ за обем и волатилност
        for symbol in active_symbols:
            try:
                # Проверяваме 24-часовия обем
                resp = requests.get(f"{self.base_url}/v5/market/tickers?category=linear&symbol={symbol}", timeout=5)
                data = resp.json()
                
                if data.get('retCode') != 0 or not data.get('result', {}).get('list'):
                    continue
                    
                volume_24h = float(data['result']['list'][0].get('volume24h', 0))
                turnover_24h = float(data['result']['list'][0].get('turnover24h', 0))
                last_price = float(data['result']['list'][0].get('lastPrice', 0))
                
                # Пропускаме символи с недостатъчен обем
                if turnover_24h < min_volume_24h:
                    continue
                    
                # Изчисляваме ATR за определяне на волатилността
                atr_value = self._calculate_atr(symbol)
                if not atr_value or last_price <= 0:
                    continue
                    
                atr_pct = (atr_value / last_price) * 100
                
                # Проверяваме дали волатилността е достатъчна
                if atr_pct < min_atr_pct:
                    continue
                    
                # Символът отговаря на всички критерии
                filtered_symbols.append(symbol)
                logging.info(f"Символ {symbol} добавен: обем=${turnover_24h:.2f}, волатилност={atr_pct:.2f}%")
                
            except Exception as e:
                logging.warning(f"Грешка при проверка на символ {symbol}: {e}")
                
        # Обновяваме списъка със символи за търговия
        self.all_symbols = filtered_symbols
        logging.info(f"Филтрирани {len(filtered_symbols)} от {len(active_symbols)} символа с достатъчен обем и волатилност.")

    def round_price(self, symbol, price):
        """Закръгляне на цена до позволения tickSize за конкретния символ."""
        info = self.symbols_info.get(symbol)
        if not info:
            return price
        tick_size = float(info['priceFilter']['tickSize'])
        # Округляваме надолу (floor) цената до най-близкия допустим тик
        return math.floor(price / tick_size) * tick_size

    def round_qty(self, symbol, qty):
        """Закръгляне на количество до позволената стъпка (qtyStep) за символа."""
        info = self.symbols_info.get(symbol)
        if not info:
            return qty
        step = float(info['lotSizeFilter']['qtyStep'])
        return math.floor(qty / step) * step

    def fetch_market_data(self, symbol):
        """Изтегля последни пазарни данни за символа: скорошни сделки и свещи от различни таймфреймове.
        Оптимизирана версия с кеширане на данните и по-малко API заявки."""
        data = {}
        current_time = time.time()
        cache_ttl = 300  # Кеширане за 5 минути (300 секунди)
        
        # Инициализираме кеш системата, ако не съществува
        if not hasattr(self, 'candles_cache'):
            self.candles_cache = {}
        
        if not hasattr(self, 'trades_cache'):
            self.trades_cache = {}
            
        if not hasattr(self, 'last_cache_update'):
            self.last_cache_update = {}
        
        # Проверяваме дали имаме кеширани данни, които все още са валидни
        if (symbol in self.candles_cache and symbol in self.last_cache_update and
                current_time - self.last_cache_update.get(symbol, 0) < cache_ttl):
            logging.debug(f"Използваме кеширани данни за {symbol} (остава {int(cache_ttl - (current_time - self.last_cache_update[symbol]))}с)")
            return self.candles_cache[symbol]
        
        # Вземаме последните ~500 сделки за анализ на ордер флоу (публична API заявка)
        try:
            # Проверяваме дали имаме кеширани trades данни, които са достатъчно нови
            if (symbol in self.trades_cache and symbol in self.last_cache_update and
                    current_time - self.last_cache_update.get(symbol, 0) < 60):  # Кеширане на trades за 1 минута
                data['trades'] = self.trades_cache[symbol]
                logging.debug(f"Използваме кеширани trades данни за {symbol}")
            else:
                # Updated to v5 API
                trades_url = f"{self.base_url}/v5/market/recent-trade?category=linear&symbol={symbol}&limit=500"
                resp = requests.get(trades_url, timeout=5)
                trades_data = resp.json()
                if trades_data.get('retCode') == 0 and 'result' in trades_data and 'list' in trades_data['result']:
                    data['trades'] = trades_data['result']['list']
                    # Кеширане на trades данните
                    self.trades_cache[symbol] = trades_data['result']['list']
                else:
                    data['trades'] = []
                    logging.warning(f"No trade data for {symbol}: {trades_data}")
        except Exception as e:
            logging.error(f"Грешка при взимане на сделки за {symbol}: {e}")
            data['trades'] = []
        
        # Дефинираме таймфреймовете, които ще използваме за мулти-таймфрейм анализ
        timeframes = {
            '5m': {'interval': '5', 'limit': 50, 'key': 'candles_5m'},
            '15m': {'interval': '15', 'limit': 50, 'key': 'candles_15m'},
            '1h': {'interval': '60', 'limit': 50, 'key': 'candles_1h'},
            '4h': {'interval': '240', 'limit': 50, 'key': 'candles_4h'}
        }
        
        # Оптимизирано batch извличане на данни за всички таймфреймове
        batch_requests = []
        batch_configs = []
        
        # Подготвяме batch requests
        for tf, config in timeframes.items():
            # Създаваме batch request
            batch_requests.append(f"{self.base_url}/v5/market/kline?category=linear&symbol={symbol}&interval={config['interval']}&limit={config['limit']}")
            batch_configs.append(config)
        
        # Изпълняваме batch requests с асинхронни заявки за по-бързо изпълнение
        import concurrent.futures
        
        def fetch_url(url_and_config):
            url, config = url_and_config
            try:
                resp = requests.get(url, timeout=5)
                candles_data = resp.json()
                if candles_data.get('retCode') == 0 and 'result' in candles_data and 'list' in candles_data['result']:
                    return config['key'], candles_data['result']['list']
                else:
                    logging.warning(f"No candle data for {symbol} {config['interval']}: {candles_data}")
                    return config['key'], []
            except Exception as e:
                logging.error(f"Грешка при взимане на свещи за {symbol} {config['interval']}: {e}")
                return config['key'], []
        
        # Изпълняваме всички заявки паралелно чрез ThreadPoolExecutor
        try:
            with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
                url_configs = list(zip(batch_requests, batch_configs))
                results = list(executor.map(fetch_url, url_configs))
                
                # Обработваме резултатите
                for key, candles in results:
                    data[key] = candles
                    # За обратна съвместимост запазваме и основните свещи (5m) с ключ 'candles'
                    if key == 'candles_5m':
                        data['candles'] = candles
        except Exception as e:
            logging.error(f"Грешка при batch извличане на свещи за {symbol}: {e}")
            # Fallback към последователно извличане при грешка
            for tf, config in timeframes.items():
                try:
                    candles_url = f"{self.base_url}/v5/market/kline?category=linear&symbol={symbol}&interval={config['interval']}&limit={config['limit']}"
                    resp = requests.get(candles_url, timeout=5)
                    candles_data = resp.json()
                    if candles_data.get('retCode') == 0 and 'result' in candles_data and 'list' in candles_data['result']:
                        data[config['key']] = candles_data['result']['list']
                        # За обратна съвместимост запазваме и основните свещи (5m) с ключ 'candles'
                        if tf == '5m':
                            data['candles'] = candles_data['result']['list']
                    else:
                        data[config['key']] = []
                        if tf == '5m':
                            data['candles'] = []
                        logging.warning(f"No candle data for {symbol} {tf}: {candles_data}")
                except Exception as e:
                    logging.error(f"Грешка при взимане на свещи за {symbol} {tf}: {e}")
                    data[config['key']] = []
                    if tf == '5m':
                        data['candles'] = []
        
        # Кеширане на данните
        self.candles_cache[symbol] = data
        self.last_cache_update[symbol] = current_time
        
        # Ограничаваме размера на кеша до 100 символа
        if len(self.candles_cache) > 100:
            # Намираме най-старите записи
            oldest_symbols = sorted(self.last_cache_update.items(), key=lambda x: x[1])[:20]
            for old_symbol, _ in oldest_symbols:
                if old_symbol in self.candles_cache:
                    del self.candles_cache[old_symbol]
                if old_symbol in self.last_cache_update:
                    del self.last_cache_update[old_symbol]
                if old_symbol in self.trades_cache:
                    del self.trades_cache[old_symbol]
                    
        return data

    def analyze_multi_timeframe(self, symbol, data):
        """
        Извършва мулти-таймфрейм анализ, като оценява силата и съгласуваността на сигналите 
        на различни таймфреймове (4ч, 1ч, 15мин, 5мин).
        
        Returns:
            dict: Резултат от мулти-таймфрейм анализа с информация за всеки таймфрейм и общата оценка
        """
        # Проверяваме дали имаме достатъчно данни за всеки таймфрейм
        required_timeframes = ['candles_4h', 'candles_1h', 'candles_15m', 'candles_5m']
        available_timeframes = []
        missing_timeframes = []
        
        for tf in required_timeframes:
            if tf in data and data[tf] and len(data[tf]) >= 10:
                available_timeframes.append(tf)
            else:
                missing_timeframes.append(tf)
                logging.warning(f"Недостатъчно данни за {symbol} в таймфрейм {tf}")
        
        # Ако нямаме никакви данни, връщаме неутрален резултат
        if not available_timeframes:
            return {
                'score': 0, 
                'alignment': -1, 
                'trend': 'neutral',
                'timeframes': {}
            }
        
        # Ако имаме поне някакви данни, ще използваме само наличните таймфреймове
        if missing_timeframes:
            logging.info(f"Анализ на {symbol} ще използва само {len(available_timeframes)} налични таймфрейма")
        
        # Анализираме всеки наличен таймфрейм
        timeframe_results = {}
        timeframe_mapping = {
            'candles_4h': '4h', 
            'candles_1h': '1h', 
            'candles_15m': '15m', 
            'candles_5m': '5m'
        }
        
        for tf_key in available_timeframes:
            tf_name = timeframe_mapping[tf_key]
            candles = data[tf_key]
            
            # Тренд анализ базиран на ЕМА
            ema20 = self.calculate_ema([float(c[4]) for c in candles if isinstance(c, list) and len(c) >= 5], 20)
            ema50 = self.calculate_ema([float(c[4]) for c in candles if isinstance(c, list) and len(c) >= 5], 50)
            
            last_close = float(candles[0][4]) if isinstance(candles[0], list) and len(candles[0]) >= 5 else 0
            
            # Определяме тренда
            trend = "neutral"
            trend_strength = 0
            
            # Проверяваме дали ema20 и ema50 не са None преди да ги сравняваме
            if ema20 is not None and ema50 is not None:
                if ema20 > ema50 and last_close > ema20:
                    trend = "strong_up"
                    trend_strength = 2
                elif ema20 > ema50:
                    trend = "up"
                    trend_strength = 1
                elif ema20 < ema50 and last_close < ema20:
                    trend = "strong_down"
                    trend_strength = -2
                elif ema20 < ema50:
                    trend = "down"
                    trend_strength = -1
            
            # Анализ на моментума (RSI)
            rsi = self.calculate_rsi([float(c[4]) for c in candles if isinstance(c, list) and len(c) >= 5], 14)
            
            # MACD анализ
            closes = [float(c[4]) for c in candles if isinstance(c, list) and len(c) >= 5]
            macd_line = self.calculate_ema(closes, 12) - self.calculate_ema(closes, 26) if len(closes) >= 26 else 0
            
            # Определяне на силата и посоката на сигнала за този таймфрейм
            signal_strength = abs(trend_strength)
            
            # Корекция на силата на сигнала според RSI
            if (trend == "up" or trend == "strong_up") and rsi > 70:
                signal_strength *= 0.7  # Намаляваме силата при пренакупеност
            elif (trend == "down" or trend == "strong_down") and rsi < 30:
                signal_strength *= 0.7  # Намаляваме силата при пренапроденост
            
            # Допълнително увеличаваме силата на сигнала, ако MACD потвърждава тренда
            if (trend == "up" or trend == "strong_up") and macd_line > 0:
                signal_strength *= 1.2
            elif (trend == "down" or trend == "strong_down") and macd_line < 0:
                signal_strength *= 1.2
            
            # Запазваме резултата за този таймфрейм
            timeframe_results[tf_name] = {
                'trend': trend,
                'trend_strength': trend_strength,
                'rsi': rsi,
                'macd': macd_line,
                'signal_strength': signal_strength
            }
        
        # Изчисляваме мулти-таймфрейм оценка и съгласуваност на трендовете
        # По-високите таймфреймове имат по-голяма тежест
        weights = {'4h': 4, '1h': 3, '15m': 2, '5m': 1}
        weighted_score = 0
        
        # Използваме само наличните таймфреймове за анализа
        available_tf_names = [timeframe_mapping[tf] for tf in available_timeframes]
        available_weights = {tf: weights[tf] for tf in available_tf_names if tf in weights}
        total_weight = sum(available_weights.values()) if available_weights else 1
        
        # Изчисляваме съгласуваността между трендовете на различните таймфреймове
        all_trends = [timeframe_results[tf]['trend_strength'] for tf in available_tf_names if tf in timeframe_results]
        
        # Съгласуваност: уникалните тенденции спрямо общия брой таймфреймове
        trend_agreement = 1.0
        if len(set([t > 0 for t in all_trends])) > 1:  # Ако има различаващи се трендове
            trend_agreement = 0.5
        
        # Ако най-високият таймфрейм противоречи на останалите, значително намаляваме съгласуваността
        if '4h' in timeframe_results:
            if (timeframe_results['4h']['trend_strength'] > 0 and len(all_trends) >= 3 and all(t < 0 for t in all_trends[1:3])) or \
               (timeframe_results['4h']['trend_strength'] < 0 and len(all_trends) >= 3 and all(t > 0 for t in all_trends[1:3])):
                trend_agreement = 0.2
        
        # Изчисляваме общата оценка, претеглена по таймфрейма
        for tf in available_tf_names:
            if tf in timeframe_results and tf in available_weights:
                trend_strength = timeframe_results[tf]['trend_strength']
                signal_strength = timeframe_results[tf]['signal_strength']
                weighted_score += (trend_strength * signal_strength * available_weights[tf])
        
        weighted_score = weighted_score / total_weight if total_weight > 0 else 0
        
        # Определяме общия MTF тренд
        mtf_trend = "neutral"
        if weighted_score > 0.7:
            mtf_trend = "strong_up"
        elif weighted_score > 0.2:
            mtf_trend = "up"
        elif weighted_score < -0.7:
            mtf_trend = "strong_down"
        elif weighted_score < -0.2:
            mtf_trend = "down"
        
        # Връщаме пълния резултат
        return {
            'score': weighted_score,
            'alignment': trend_agreement,
            'trend': mtf_trend,
            'timeframes': timeframe_results
        }

    def analyze_market(self, symbol, data):
        """Анализира пазарните данни с AI подход и връща сигнал 'Buy', 'Sell' или None."""
        trades = data.get('trades', [])
        candles = data.get('candles', [])

        # Проверка дали имаме достатъчно данни
        if not trades or len(trades) < 100 or not candles or len(candles) < 50:
            return None
            
        # Първо извършваме мулти-таймфрейм анализ
        mtf_analysis = self.analyze_multi_timeframe(symbol, data)

        # Get features from AI predictor if available
        features = self.ai_predictor.features.get(symbol, {}) if hasattr(self, 'ai_predictor') else {}

        # Изчисляване на подобрен Order Flow анализ
        buy_vol = 0.0
        sell_vol = 0.0
        buy_vol_aggressive = 0.0  # Обем на агресивни покупки (на цена аск)
        sell_vol_aggressive = 0.0  # Обем на агресивни продажби (на цена бид)

        # Анализ на ценови нива и натрупвания на лимитни поръчки
        price_buckets = {}  # За идентифициране на ключови ценови нива
        price_bucket_size = 0.0001  # Размер на ценовите групи (0.01%)
        time_weighted_prices = []  # За хронологичен анализ на ценовото движение

        # Допълнителни метрики за delta volume (кумулативен дисбаланс)
        delta_volume = 0.0  # Общ дисбаланс на обема (buy-sell)
        delta_aggressive = 0.0  # Дисбаланс на агресивни поръчки
        time_slices = []  # Разделяме данните на времеви интервали за по-детайлен анализ

        # Получаваме последните цени bid/ask за анализ на агресивни поръчки
        last_bid = last_ask = None

        # Сортираме сделките по време (от най-стари към най-нови)
        try:
            sorted_trades = sorted(trades, key=lambda x: int(x.get('time', x.get('timestamp', 0))))

            # Извличаме времева рамка за анализа и определяме интервалите
            if len(sorted_trades) >= 2:
                start_time = int(sorted_trades[0].get('time', sorted_trades[0].get('timestamp', 0)))
                end_time = int(sorted_trades[-1].get('time', sorted_trades[-1].get('timestamp', 0)))
                time_range = end_time - start_time
                slice_interval = time_range // 5  # Разделяме на 5 времеви интервала

                # Инициализираме времевите интервали
                for i in range(5):
                    time_slices.append({
                        'start': start_time + i * slice_interval,
                        'end': start_time + (i + 1) * slice_interval,
                        'buy_vol': 0.0,
                        'sell_vol': 0.0,
                        'delta': 0.0,
                        'prices': []
                    })

            # Ако можем да вземем bid/ask от последните данни
            if self.symbols_info.get(symbol):
                for trade in sorted_trades:
                    try:
                        # Updated field names for v5 API
                        qty = float(trade.get('size', 0))
                        price = float(trade.get('price', 0))
                        trade_time = int(trade.get('time', trade.get('timestamp', 0)))
                    except:
                        qty = float(trade.get('qty', 0))  # Fallback
                        price = float(trade.get('price', 0))
                        trade_time = int(trade.get('time', trade.get('timestamp', 0)))

                    side = trade.get('side', '')

                    # Групираме цените за анализ на натрупване на поръчки
                    price_bucket = round(price / price_bucket_size) * price_bucket_size
                    if price_bucket not in price_buckets:
                        price_buckets[price_bucket] = {
                            'buy_vol': 0.0,
                            'sell_vol': 0.0,
                            'total_vol': 0.0,
                            'trades_count': 0
                        }

                    # Добавяме информация за сделката към съответната ценова група
                    price_buckets[price_bucket]['trades_count'] += 1
                    price_buckets[price_bucket]['total_vol'] += qty

                    # Записваме цената с времето за хронологичен анализ
                    time_weighted_prices.append((trade_time, price, qty, side))

                    # Добавяме данните към съответния времеви интервал
                    for time_slice in time_slices:
                        if time_slice['start'] <= trade_time < time_slice['end']:
                            time_slice['prices'].append(price)
                            if side.lower() == 'buy':
                                time_slice['buy_vol'] += qty
                            else:
                                time_slice['sell_vol'] += qty
                            time_slice['delta'] = time_slice['buy_vol'] - time_slice['sell_vol']
                            break

                    if side.lower() == 'buy':
                        buy_vol += qty
                        price_buckets[price_bucket]['buy_vol'] += qty
                        delta_volume += qty  # Натрупваме delta volume

                        # Ако цената е близо до аск, това вероятно е агресивна покупка
                        if last_ask and price >= last_ask * 0.9999:
                            buy_vol_aggressive += qty
                            delta_aggressive += qty
                    elif side.lower() == 'sell':
                        sell_vol += qty
                        price_buckets[price_bucket]['sell_vol'] += qty
                        delta_volume -= qty  # Изваждаме от delta volume

                        # Ако цената е близо до bid, това вероятно е агресивна продажба
                        if last_bid and price <= last_bid * 1.0001:
                            sell_vol_aggressive += qty
                            delta_aggressive -= qty

                    # Актуализиране на bid/ask спрямо текущите данни
                    if side.lower() == 'buy':
                        last_bid = price
                    else:
                        last_ask = price
            else:
                # Ако нямаме bid/ask, просто броим общия обем
                for trade in sorted_trades:
                    try:
                        qty = float(trade.get('size', 0))
                        price = float(trade.get('price', 0))
                        trade_time = int(trade.get('time', trade.get('timestamp', 0)))
                    except:
                        qty = float(trade.get('qty', 0))  # Fallback
                        price = float(trade.get('price', 0))
                        trade_time = int(trade.get('time', trade.get('timestamp', 0)))

                    side = trade.get('side', '')

                    # Групираме цените за анализ на натрупване на поръчки
                    price_bucket = round(price / price_bucket_size) * price_bucket_size
                    if price_bucket not in price_buckets:
                        price_buckets[price_bucket] = {
                            'buy_vol': 0.0,
                            'sell_vol': 0.0,
                            'total_vol': 0.0,
                            'trades_count': 0
                        }

                    # Добавяме информация за сделката към съответната ценова група
                    price_buckets[price_bucket]['trades_count'] += 1
                    price_buckets[price_bucket]['total_vol'] += qty

                    # Добавяме данните към съответния времеви интервал
                    for time_slice in time_slices:
                        if time_slice['start'] <= trade_time < time_slice['end']:
                            time_slice['prices'].append(price)
                            if side.lower() == 'buy':
                                time_slice['buy_vol'] += qty
                            else:
                                time_slice['sell_vol'] += qty
                            time_slice['delta'] = time_slice['buy_vol'] - time_slice['sell_vol']
                            break

                    if side.lower() == 'buy':
                        buy_vol += qty
                        price_buckets[price_bucket]['buy_vol'] += qty
                        delta_volume += qty
                    elif side.lower() == 'sell':
                        sell_vol += qty
                        price_buckets[price_bucket]['sell_vol'] += qty
                        delta_volume -= qty
        except Exception as e:
            logging.error(f"Грешка при анализ на Order Flow: {e}")
            # При грешка просто използваме простия подход
            buy_vol = sell_vol = 0
            for trade in trades:
                try:
                    qty = float(trade.get('size', 0))
                except:
                    qty = float(trade.get('qty', 0))
                side = trade.get('side', '')
                if side.lower() == 'buy':
                    buy_vol += qty
                elif side.lower() == 'sell':
                    sell_vol += qty

        total_vol = buy_vol + sell_vol

        # Проверка за минимален обем на търговия - по-високи изисквания
        if total_vol < 2000:  # Изисква значителен обем
            return None

        net_vol = buy_vol - sell_vol  # положителен => доминират купувачите, отрицателен => продавачите

        # Анализ на агресивност на Order Flow
        aggression_buy_ratio = buy_vol_aggressive / buy_vol if buy_vol > 0 else 0
        aggression_sell_ratio = sell_vol_aggressive / sell_vol if sell_vol > 0 else 0

        # Калкулираме delta volume ratio (нормализирана разлика между buy-sell обемите)
        delta_ratio = delta_volume / total_vol if total_vol > 0 else 0
        delta_aggressive_ratio = delta_aggressive / (buy_vol_aggressive + sell_vol_aggressive) if (buy_vol_aggressive + sell_vol_aggressive) > 0 else 0

        # Откриваме ценови нива с най-голямо натрупване на обем (потенциални нива на подкрепа/съпротива)
        support_resistance_levels = []
        if price_buckets:
            # Сортираме ценовите нива по общ обем
            sorted_levels = sorted(price_buckets.items(), key=lambda x: x[1]['total_vol'], reverse=True)
            # Вземаме топ 5 нива с най-голям обем
            top_levels = sorted_levels[:5]

            for price_level, data in top_levels:
                level_type = "neutral"
                # Определяме дали нивото е подкрепа (повече покупки) или съпротива (повече продажби)
                if data['buy_vol'] > data['sell_vol'] * 1.5:  # 50% повече покупки
                    level_type = "support"
                elif data['sell_vol'] > data['buy_vol'] * 1.5:  # 50% повече продажби
                    level_type = "resistance"

                support_resistance_levels.append({
                    'price': price_level,
                    'type': level_type,
                    'volume': data['total_vol'],
                    'trades': data['trades_count']
                })

        # Анализираме delta volume trend в последователни времеви интервали
        delta_trend = "neutral"
        if len(time_slices) >= 3:
            # Проверяваме последните 3 времеви интервала
            recent_deltas = [slice['delta'] for slice in time_slices[-3:] if slice['buy_vol'] + slice['sell_vol'] > 0]

            if len(recent_deltas) >= 2:
                # Ако последните делти са позитивни и растящи -> силен бичи тренд
                if all(d > 0 for d in recent_deltas) and recent_deltas[-1] > recent_deltas[0]:
                    delta_trend = "strong_bullish"
                # Ако последните делти са позитивни -> бичи тренд
                elif all(d > 0 for d in recent_deltas):
                    delta_trend = "bullish"
                # Ако последните делти са негативни и намаляващи -> силен мечи тренд
                elif all(d < 0 for d in recent_deltas) and recent_deltas[-1] < recent_deltas[0]:
                    delta_trend = "strong_bearish"
                # Ако последните делти са негативни -> мечи тренд
                elif all(d < 0 for d in recent_deltas):
                    delta_trend = "bearish"
                # Ако има смяна на посоката от негативна към позитивна -> потенциален обрат нагоре
                elif recent_deltas[0] < 0 and recent_deltas[-1] > 0:
                    delta_trend = "reversal_up"
                # Ако има смяна на посоката от позитивна към негативна -> потенциален обрат надолу
                elif recent_deltas[0] > 0 and recent_deltas[-1] < 0:
                    delta_trend = "reversal_down"

        # VWAP на база скорошните сделки
        vwap = None
        if total_vol > 0:
            sum_pq = 0.0
            for trade in trades:
                price = float(trade.get('price', 0))
                try:
                    qty = float(trade.get('size', 0))
                except:
                    qty = float(trade.get('qty', 0))
                sum_pq += price * qty
            vwap = sum_pq / total_vol

        # Подготовка на данни за изчисление
        highs = []
        lows = []
        closes = []
        opens = []
        volumes = []
        hlc3_prices = []  # (High + Low + Close) / 3

        for c in candles:
            if isinstance(c, list) and len(c) >= 6:  # v5 API format
                open_price = float(c[1])
                high_price = float(c[2])
                low_price = float(c[3])
                close_price = float(c[4])
                volume = float(c[5])
            elif isinstance(c, dict):  # old format
                open_price = float(c.get('open', 0))
                high_price = float(c.get('high', 0))
                low_price = float(c.get('low', 0))
                close_price = float(c.get('close', 0))
                volume = float(c.get('volume', 0))
            else:
                continue

            opens.append(open_price)
            highs.append(high_price)
            lows.append(low_price)
            closes.append(close_price)
            volumes.append(volume)
            hlc3_prices.append((high_price + low_price + close_price) / 3)

        # Проверка за достатъчно данни
        if len(closes) < 50:
            return None

        # === Подобрен технически анализ ===

        # Функция за изчисление на EMA
        def calculate_ema(prices, period):
            if len(prices) < period:
                return None

            ema_values = []
            sma = sum(prices[:period]) / period
            ema_values.append(sma)

            alpha = 2 / (period + 1)
            for price in prices[period:]:
                new_val = alpha * price + (1 - alpha) * ema_values[-1]
                ema_values.append(new_val)

            return ema_values[-1]

        # Изчисляване на ATR (Average True Range) за по-добра оценка на волатилността
        def calculate_atr(highs, lows, closes, period=14):
            if len(highs) < period + 1:
                return None

            import numpy as np
            highs_array = np.array(highs)
            lows_array = np.array(lows)
            closes_array = np.array(closes)

            # Подготвяме масиви за изчисление
            true_ranges = np.zeros(len(highs_array))

            # Първа TR стойност
            true_ranges[0] = highs_array[0] - lows_array[0]

            # Векторизирано изчисление на TR стойности
            tr1 = highs_array[1:] - lows_array[1:]
            tr2 = np.abs(highs_array[1:] - closes_array[:-1])
            tr3 = np.abs(lows_array[1:] - closes_array[:-1])

            # Вземаме максимума от трите стойности за всеки ден
            true_ranges[1:] = np.maximum(np.maximum(tr1, tr2), tr3)

            # ATR е средна стойност от последните N true ranges
            if len(true_ranges) < period:
                return np.mean(true_ranges)

            return np.mean(true_ranges[-period:])

        # EMA 20, 50 и 200 изчисление
        ema20 = calculate_ema(closes, 20)
        ema50 = calculate_ema(closes, 50)
        ema200 = calculate_ema(closes, 200) if len(closes) >= 200 else None

        # Изчисляване на MACD
        ema12 = calculate_ema(closes, 12)
        ema26 = calculate_ema(closes, 26)
        macd_line = ema12 - ema26 if (ema12 is not None and ema26 is not None) else None

        # Изчисляване на ATR и разделянето му спрямо цената за сравнима стойност
        atr = calculate_atr(highs, lows, closes, 14)

        # Изчисляване на ATR като процент от цената
        current_price = closes[-1]
        atr_pct = (atr / current_price * 100) if atr and current_price > 0 else None

        # Проверка дали имаме валидни EMA стойности
        if ema20 is None or ema50 is None:
            return None

        # По-сложен RSI изчисление за 14 периода - векторизиран с NumPy
        def calculate_rsi(prices, period=14):
            if len(prices) < period + 1:
                return 50  # Неутрална стойност при липса на данни

            import numpy as np
            prices_array = np.array(prices)

            # Изчисляваме промените в цената
            deltas = np.diff(prices_array)

            # Разделяме печалби и загуби
            gains = np.where(deltas > 0, deltas, 0)
            losses = np.where(deltas < 0, -deltas, 0)

            # Първоначална средна печалба и загуба
            avg_gain = np.mean(gains[:period])
            avg_loss = np.mean(losses[:period])

            # Изглаждане с EMA-тип подход
            for i in range(period, len(deltas)):
                avg_gain = (avg_gain * (period - 1) + gains[i]) / period
                avg_loss = (avg_loss * (period - 1) + losses[i]) / period

            if avg_loss == 0:
                return 100

            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))

            return rsi

        rsi = calculate_rsi(closes, 14)

        # Вземане на цена от последната сделка
        last_price = float(trades[-1]['price']) if trades else None

        if not last_price:
            return None

        # === AI подход за генериране на сигнали ===
        signal = None

        # По-строг праг за дисбаланс в обема
        vol_threshold = 0.3  # Изисква 30% дисбаланс

        # Анализ на тренда с множество потвърждения и прецизност
        strong_trend_up = ema20 > ema50 and ema50 > ema200 if ema200 else ema20 > ema50
        strong_trend_down = ema20 < ema50 and ema50 < ema200 if ema200 else ema20 < ema50

        # Средно-силен тренд
        medium_trend_up = ema20 > ema50 and last_price > ema20
        medium_trend_down = ema20 < ema50 and last_price < ema20

        # Анализ на дивергенции (базово)
        price_making_higher_highs = False
        price_making_lower_lows = False

        if len(closes) >= 10:
            last_highs = [max(closes[i:i+5]) for i in range(len(closes)-10, len(closes)-5, 5)]
            last_lows = [min(closes[i:i+5]) for i in range(len(closes)-10, len(closes)-5, 5)]

            price_making_higher_highs = last_highs[1] > last_highs[0] if len(last_highs) > 1 else False
            price_making_lower_lows = last_lows[1] < last_lows[0] if len(last_lows) > 1 else False

        # Анализ на волатилността с ATR
        high_volatility = atr_pct > 1.0 if atr_pct else False  # Над 1% ATR/цена
        low_volatility = atr_pct < 0.5 if atr_pct else False   # Под 0.5% ATR/цена

        # Ако волатилността е твърде ниска, пропускаме сигнала
        if low_volatility:
            return None

        # Значителен дисбаланс в обемите и агресивен flow
        strong_buy_flow = net_vol > 0 and total_vol > 0 and (net_vol / total_vol) > vol_threshold
        strong_sell_flow = net_vol < 0 and total_vol > 0 and (net_vol / total_vol) < -vol_threshold

        # Допълнителни условия за агресивността на Order Flow
        aggressive_buy = aggression_buy_ratio > 0.6  # Повече от 60% агресивни покупки
        aggressive_sell = aggression_sell_ratio > 0.6  # Повече от 60% агресивни продажби

        # Интегриране на Delta Volume анализа в сигналите
        delta_buy_signal = delta_ratio > 0.25 or delta_trend in ["strong_bullish", "reversal_up"]
        delta_sell_signal = delta_ratio < -0.25 or delta_trend in ["strong_bearish", "reversal_down"]

        # Анализ на Z-score и Mean Reversion
        z_score = features.get('z_score', 0)
        price_change_z_score = features.get('price_change_z_score', 0)
        is_extreme = features.get('is_extreme', 0)
        is_positive_extreme = features.get('is_positive_extreme', 0)
        is_negative_extreme = features.get('is_negative_extreme', 0)
        autocorrelation = features.get('autocorrelation', 0)
        distance_from_mean = features.get('distance_from_mean', 0)
        mean_reversion_signal = features.get('mean_reversion_signal', 0)
        mean_reversion_buy = features.get('mean_reversion_buy', 0)
        mean_reversion_sell = features.get('mean_reversion_sell', 0)

        # Анализ на натрупвания в лимитни поръчки (подкрепа/съпротива)
        limit_order_signals = []
        current_price = float(trades[-1]['price']) if trades else None

        if current_price and support_resistance_levels:
            for level in support_resistance_levels:
                level_price = level['price']
                price_difference = abs(current_price - level_price) / current_price

                # Ако цената е близо до значимо ниво (в рамките на 0.5%)
                if price_difference < 0.005:
                    if level['type'] == "support" and current_price >= level_price:
                        # Потенциален отскок нагоре от подкрепа
                        limit_order_signals.append(("buy", level['volume'] / total_vol))
                    elif level['type'] == "resistance" and current_price <= level_price:
                        # Потенциален отскок надолу от съпротива
                        limit_order_signals.append(("sell", level['volume'] / total_vol))

        # Силни подкрепа/съпротива сигнали базирани на лимитни поръчки
        limit_buy_signal = any(signal[0] == "buy" and signal[1] > 0.15 for signal in limit_order_signals)
        limit_sell_signal = any(signal[0] == "sell" and signal[1] > 0.15 for signal in limit_order_signals)

        # VWAP като подкрепа/съпротива
        price_above_vwap = vwap is not None and last_price > vwap
        price_below_vwap = vwap is not None and last_price < vwap

        # Добавени проверки за RSI
        oversold = rsi < 30
        overbought = rsi > 70
        rsi_neutral = 40 <= rsi <= 60

        # Добавен анализ на импулс и обем
        volume_increasing = False
        if len(volumes) >= 5:
            avg_recent_vol = sum(volumes[-3:]) / 3
            avg_prior_vol = sum(volumes[-8:-3]) / 5
            volume_increasing = avg_recent_vol > avg_prior_vol * 1.3  # 30% увеличение

        # Сложна претеглена система за сигнали
        buy_score = 0
        sell_score = 0

        # Компоненти на scoring системата
        if strong_trend_up: buy_score += 3
        if medium_trend_up: buy_score += 2
        if strong_trend_down: sell_score += 3
        if medium_trend_down: sell_score += 2

        if price_above_vwap: buy_score += 1
        if price_below_vwap: sell_score += 1

        if strong_buy_flow: buy_score += 2
        if strong_sell_flow: sell_score += 2

        if aggressive_buy: buy_score += 2
        if aggressive_sell: sell_score += 2

        # Добавяме Delta Volume компоненти с голяма тежест (3 точки)
        if delta_buy_signal: buy_score += 3  # Силен сигнал от delta volume анализа
        if delta_sell_signal: sell_score += 3

        # Добавяме сигнали от лимитни поръчки (значителни нива на подкрепа/съпротива)
        if limit_buy_signal: buy_score += 2
        if limit_sell_signal: sell_score += 2

        # Допълнителни комбинирани сигнали
        if delta_buy_signal and limit_buy_signal: buy_score += 1  # Допълнителна точка за потвърждение
        if delta_sell_signal and limit_sell_signal: sell_score += 1

        # Сигнали за reversal (обръщане на тренда) от delta volume
        if delta_trend == "reversal_up" and oversold: buy_score += 2  # Силен сигнал за обрат нагоре
        if delta_trend == "reversal_down" and overbought: sell_score += 2  # Силен сигнал за обрат надолу

        if oversold: buy_score += 1  # По-голям потенциал за обрат нагоре
        if overbought: sell_score += 1  # По-голям потенциал за обрат надолу

        if rsi_neutral:
            if medium_trend_up: buy_score += 1
            if medium_trend_down: sell_score += 1

        if high_volatility and volume_increasing:
            if medium_trend_up: buy_score += 1
            if medium_trend_down: sell_score += 1

        # Противоречиви данни намаляват вероятността за добър сигнал
        if strong_trend_up and aggressive_sell: buy_score -= 2
        if strong_trend_down and aggressive_buy: sell_score -= 2

        # Противоречия между delta volume и класическия анализ
        if delta_buy_signal and strong_sell_flow: buy_score -= 1
        if delta_sell_signal and strong_buy_flow: sell_score -= 1

        # Добавяме Z-score компоненти към scoring системата
        if is_negative_extreme == 1 and (oversold or distance_from_mean < -1.5):
            # Екстремно ниска цена + пренапродаден -> силен сигнал за покупка (потенциален обрат)
            buy_score += 3

        if is_positive_extreme == 1 and (overbought or distance_from_mean > 1.5):
            # Екстремно висока цена + пренакупен -> силен сигнал за продажба (потенциален обрат)
            sell_score += 3

        # Mean Reversion сигнали
        if mean_reversion_buy == 1:
            # Силен сигнал за обрат нагоре базиран на mean reversion
            buy_score += 2.5

            # Добавяме допълнителна тежест ако и други индикатори подкрепят
            if oversold:
                buy_score += 1

        if mean_reversion_sell == 1:
            # Силен сигнал за обрат надолу базиран на mean reversion
            sell_score += 2.5

            # Добавяме допълнителна тежест ако и други индикатори подкрепят
            if overbought:
                sell_score += 1

        # Средна автокорелация - за филтриране на сигнали
        if autocorrelation < -0.4:
            # Силно отрицателна автокорелация - високо mean reversion
            if z_score < -1.5:  # Цената е значително под средната
                buy_score += 1.5
            elif z_score > 1.5:  # Цената е значително над средната
                sell_score += 1.5
        elif autocorrelation > 0.4:
            # Силно положителна автокорелация - trend following
            if medium_trend_up:
                buy_score += 1.5
            elif medium_trend_down:
                sell_score += 1.5

        # Бързи ценови аномалии (внезапни движения)
        if price_change_z_score > 2.5:  # Много голямо възходящо движение
            # Ако вече имаме дълъг тренд нагоре, добавяме към buy сигнала
            if strong_trend_up:
                buy_score += 1  # Trend continuation
            else:
                sell_score += 1  # Мечи сигнал за обрат след голям скок
        elif price_change_z_score < -2.5:  # Много голямо низходящо движение
            # Ако вече имаме дълъг тренд надолу, добавяме към sell сигнала
            if strong_trend_down:
                sell_score += 1  # Trend continuation
            else:
                buy_score += 1  # Бичи сигнал за обрат след голям спад

        # Корекция за противоречиви сигнали
        if mean_reversion_buy == 1 and strong_trend_down:
            buy_score -= 1  # Противоречие: mean reversion срещу силен тренд
        if mean_reversion_sell == 1 and strong_trend_up:
            sell_score -= 1  # Противоречие: mean reversion срещу силен тренд

        # Вземаме резултатите от мулти-таймфрейм анализа
        mtf_analysis = self.analyze_multi_timeframe(symbol, data)
        
        # Прилагаме мулти-таймфрейм филтър към нашия сигнал
        # Оценката и съгласуваността на трендовете между таймфреймовете
        mtf_score = mtf_analysis['score']
        mtf_alignment = mtf_analysis['alignment']
        mtf_trend = mtf_analysis['trend']
        
        # Добавяме логване за MTF анализа
        logging.info(f"MTF анализ за {symbol}: тренд={mtf_trend}, оценка={mtf_score:.2f}, съгласуваност={mtf_alignment:.2f}")
        
        # Коригираме финалните балове според MTF анализа
        if mtf_alignment >= 0.8:  # Висока съгласуваност между таймфреймовете
            if mtf_trend in ['up', 'strong_up']:
                buy_score += 2  # Бонус точки за съгласуван възходящ тренд
                sell_score -= 1
            elif mtf_trend in ['down', 'strong_down']:
                sell_score += 2  # Бонус точки за съгласуван низходящ тренд
                buy_score -= 1
        
        # Ако 4-часовият таймфрейм е силно противоположен на нашия сигнал, намаляваме шансовете
        if 'timeframes' in mtf_analysis and '4h' in mtf_analysis['timeframes']:
            tf_4h = mtf_analysis['timeframes']['4h']
            if tf_4h['trend'] == 'strong_up' and sell_score > buy_score:
                sell_score -= 1.5  # Намаляваме sell сигнала, ако 4h е силно възходящ
            elif tf_4h['trend'] == 'strong_down' and buy_score > sell_score:
                buy_score -= 1.5  # Намаляваме buy сигнала, ако 4h е силно низходящ
        
        # Определяне на сигнала въз основа на финалната scoring система
        min_score_threshold = 5  # Минимален бал за генериране на сигнал (намален от 6)

        if buy_score >= min_score_threshold and buy_score > sell_score + 2:
            # Допълнителна проверка за съвместимост с MTF анализа
            if mtf_trend in ['neutral', 'up', 'strong_up'] or mtf_alignment < 0.5:
                signal = 'Buy'
        elif sell_score >= min_score_threshold and sell_score > buy_score + 2:
            # Допълнителна проверка за съвместимост с MTF анализа
            if mtf_trend in ['neutral', 'down', 'strong_down'] or mtf_alignment < 0.5:
                signal = 'Sell'

        # Ограничаване на броя сделки 
        # Проверяваме дали са минали поне 4 часа (48 свещи по 5 мин) от последните сделки
        if signal and hasattr(self, 'last_trade_time') and symbol in self.last_trade_time:
            last_time = self.last_trade_time[symbol]
            current_time = time.time()
            # Изисква 4 часа (14400 секунди) между сигналите за един и същ символ
            if current_time - last_time < 14400:
                signal = None

        # Запис на времето при валиден сигнал
        if signal:
            if not hasattr(self, 'last_trade_time'):
                self.last_trade_time = {}
            self.last_trade_time[symbol] = time.time()

            # Запис на допълнителна информация за сигнала за обучение
            if not hasattr(self, 'signal_log'):
                self.signal_log = []

            signal_info = {
                'symbol': symbol,
                'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                'signal': signal,
                'price': last_price,
                'buy_score': buy_score,
                'sell_score': sell_score,
                'ema20': ema20,
                'ema50': ema50,
                'rsi': rsi,
                'atr_pct': atr_pct,
                'volume': total_vol,
                'net_volume': net_vol,
                'delta_volume': {
                    'ratio': delta_ratio,
                    'aggressive_ratio': delta_aggressive_ratio,
                    'trend': delta_trend
                },
                'limit_orders': {
                    'support_resistance': support_resistance_levels[:3] if support_resistance_levels else [],
                    'buy_signal': limit_buy_signal,
                    'sell_signal': limit_sell_signal
                }
            }

            self.signal_log.append(signal_info)
            logging.info(f"AI Signal generated: {symbol} {signal} | Buy score: {buy_score}, Sell score: {sell_score} | Delta ratio: {delta_ratio:.2f}, Trend: {delta_trend}")

        return signal

    def execute_smart_order(self, symbol, signal, order_type="iceberg"):
        """
        Изпълнява интелигентна поръчка за намаляване на пазарното въздействие.
        Поддържа: iceberg, twap и vwap стратегии
        """
        side = 'Buy' if signal == 'Buy' else 'Sell'

        # Получаваме текущата цена
        current_price = None
        try:
            if self.test_mode:
                resp = requests.get(f"{self.base_url}/v5/market/tickers?category=linear&symbol={symbol}", timeout=5)
                data = resp.json()
                if data.get('retCode') == 0 and data.get('result', {}).get('list'):
                    current_price = float(data['result']['list'][0]['lastPrice'])
            else:
                tick = self.session.get_tickers(category='linear', symbol=symbol)
                if tick.get('retCode') == 0 and tick['result']['list']:
                    current_price = float(tick['result']['list'][0]['lastPrice'])
        except Exception as e:
            logging.error(f"Грешка при взимане на цена за {symbol}: {e}")
            return

        if not current_price:
            logging.error(f"Не може да се определи цена за {symbol}")
            return

        # Изчисляваме размера на поръчката
        self.update_balance()
        position_value = self.balance * self.risk_percent
        total_qty = position_value / current_price
        total_qty = self.round_qty(symbol, total_qty)

        if order_type == "iceberg":
            # Iceberg order - разделяме на по-малки поръчки за да скрием реалния обем
            return self._execute_iceberg_order(symbol, side, total_qty, current_price)
        elif order_type == "twap":
            # Time-Weighted Average Price (TWAP)
            return self._execute_twap_order(symbol, side, total_qty, current_price)
        elif order_type == "vwap":
            # Volume-Weighted Average Price (VWAP)
            return self._execute_vwap_order(symbol, side, total_qty, current_price)
        else:
            # Стандартна поръчка
            return self.execute_trade(symbol, signal)

    def _execute_iceberg_order(self, symbol, side, total_qty, current_price):
        """
        Изпълнява Iceberg поръчка, разделяйки голям обем на малки части.
        Показва само малка част от поръчката наведнъж.
        """
        if self.test_mode:
            logging.info(f"TEST MODE: Симулиране на Iceberg поръчка за {symbol} {side}, общо: {total_qty}")

            # Определяме TP/SL базирано на ATR
            atr_value = self._calculate_atr(symbol)

            if atr_value:
                # Използваме ATR за определяне на TP/SL
                if side == 'Buy':
                    tp_price = current_price + (atr_value * 3.0)
                    sl_price = current_price - (atr_value * 1.5)
                else:  # Sell
                    tp_price = current_price - (atr_value * 3.0)
                    sl_price = current_price + (atr_value * 1.5)
            else:
                # Стандартни проценти
                if side == 'Buy':
                    tp_price = current_price * 1.02  # TP 2% над входа
                    sl_price = current_price * 0.99  # SL 1% под входа
                else:  # Sell
                    tp_price = current_price * 0.98  # TP 2% под входа
                    sl_price = current_price * 1.01  # SL 1% над входа

            # Закръгляме според изискванията
            tp_price = self.round_price(symbol, tp_price)
            sl_price = self.round_price(symbol, sl_price)

            # Запазваме детайли за позицията
            self.open_positions[symbol] = {
                'side': side,
                'entry_price': current_price,
                'tp': tp_price,
                'sl': sl_price,
                'original_sl': sl_price,
                'atr': atr_value,
                'risk_reward': abs(tp_price - current_price) / abs(current_price - sl_price) if abs(current_price - sl_price) > 0 else 0,
                'trailing_sl_active': False
            }

            # Изпращаме известие
            msg = (f"🔄 TEST MODE: Iceberg поръчка за {symbol} {side}\n"
                   f"Общ обем: {total_qty:.4f}\n"
                   f"Средна цена: {current_price:.4f}\n"
                   f"TP: {tp_price:.4f}, SL: {sl_price:.4f}\n"
                   f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            self.send_telegram(msg)
            return

        # В реален режим разделяме на 5-8 по-малки поръчки
        num_chunks = min(8, max(5, int(total_qty / 5)))
        chunk_size = total_qty / num_chunks
        chunk_size = self.round_qty(symbol, chunk_size)

        if chunk_size <= 0:
            logging.warning(f"Размерът на поръчката е твърде малък за Iceberg: {total_qty}")
            return self.execute_trade(symbol, side)

        # Получаваме правилната категория
        category = 'linear'

        try:
            # Изчисляваме ATR за по-прецизно TP/SL
            atr_value = self._calculate_atr(symbol)

            if atr_value:
                # Използваме ATR за определяне на TP/SL
                if side == 'Buy':
                    tp_price = current_price + (atr_value * 3.0)
                    sl_price = current_price - (atr_value * 1.5)
                else:  # Sell
                    tp_price = current_price - (atr_value * 3.0)
                    sl_price = current_price + (atr_value * 1.5)
            else:
                # Стандартни проценти
                if side == 'Buy':
                    tp_price = current_price * 1.02  # TP 2% над входа
                    sl_price = current_price * 0.99  # SL 1% под входа
                else:  # Sell
                    tp_price = current_price * 0.98  # TP 2% под входа
                    sl_price = current_price * 1.01  # SL 1% над входа

            # Закръгляме според изискванията
            tp_price = self.round_price(symbol, tp_price)
            sl_price = self.round_price(symbol, sl_price)

            # Изпълняваме поръчките на части с малки закъснения между тях
            successful_orders = 0
            total_filled_qty = 0

            # Цената може леко да се промени между поръчките
            avg_price = 0

            for i in range(num_chunks):
                # Последната част нека е по-малка, за да компенсира закръглянията
                if i == num_chunks - 1:
                    remaining_qty = total_qty - total_filled_qty
                    if remaining_qty <= 0:
                        break
                    current_chunk = self.round_qty(symbol, remaining_qty)
                else:
                    current_chunk = chunk_size

                # Пропускаме малки количества
                if current_chunk <= 0:
                    continue

                # Изпълняваме частта
                resp = self.session.place_order(
                    category=category,
                    symbol=symbol,
                    side=side,
                    orderType='Market',
                    qty=str(current_chunk),
                    positionIdx=0,
                    timeInForce='GoodTillCancel'
                )

                if resp.get('retCode') == 0:
                    successful_orders += 1
                    total_filled_qty += current_chunk

                    # Опитваме се да получим цената на изпълнение
                    try:
                        order_id = resp.get('result', {}).get('orderId')
                        if order_id:
                            order_info = self.session.get_order_history(
                                category=category,
                                symbol=symbol,
                                orderId=order_id
                            )
                            if order_info.get('retCode') == 0:
                                order_data = order_info.get('result', {}).get('list', [{}])[0]
                                exec_price = float(order_data.get('avgPrice', current_price))
                                avg_price = (avg_price * (successful_orders - 1) + exec_price) / successful_orders
                    except Exception as e:
                        logging.warning(f"Не може да се получи цена на изпълнение: {e}")
                        # Използваме текущата цена като приближение
                        avg_price = (avg_price * (successful_orders - 1) + current_price) / successful_orders
                else:
                    logging.error(f"Грешка при изпълнение на част от Iceberg поръчка: {resp.get('retMsg')}")

                # Малко закъснение между поръчките
                time.sleep(0.5)

            # Ако поне една поръчка е успешна, задаваме TP/SL за позицията
            if successful_orders > 0:
                # Използваме средната цена на изпълнение, ако е налична
                if avg_price <= 0:
                    avg_price = current_price

                # Задаваме TP/SL за позицията
                tp_sl_resp = self.session.set_trading_stop(
                    category=category,
                    symbol=symbol,
                    takeProfit=str(tp_price),
                    stopLoss=str(sl_price),
                    positionIdx=0
                )

                if tp_sl_resp.get('retCode') != 0:
                    logging.error(f"Грешка при задаване на TP/SL: {tp_sl_resp.get('retMsg')}")

                # Запазваме детайли за позицията
                self.open_positions[symbol] = {
                    'side': side,
                    'entry_price': avg_price,
                    'tp': tp_price,
                    'sl': sl_price,
                    'original_sl': sl_price,
                    'atr': atr_value,
                    'risk_reward': abs(tp_price - avg_price) / abs(avg_price - sl_price) if abs(avg_price - sl_price) > 0 else 0,
                    'trailing_sl_active': False,
                    'open_time': datetime.now()
                }

                # Изпращаме известие
                msg = (f"🚀 Iceberg {side} позиция на {symbol}\n"
                       f"Изпълнени части: {successful_orders}/{num_chunks}\n"
                       f"Общо количество: {total_filled_qty:.4f}\n"
                       f"Средна цена: {avg_price:.4f}\n"
                       f"TP: {tp_price:.4f}, SL: {sl_price:.4f}\n"
                       f"Време: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                self.send_telegram(msg)

                return True
            else:
                logging.error(f"Неуспешно изпълнение на Iceberg поръчка за {symbol}")
                return False

        except Exception as e:
            logging.error(f"Грешка при изпълнение на Iceberg поръчка: {e}")
            return False

    def _execute_twap_order(self, symbol, side, total_qty, current_price):
        """
        Изпълнява TWAP (Time-Weighted Average Price) поръчка, 
        разпределяйки обема равномерно във времето.
        """
        if self.test_mode:
            logging.info(f"TEST MODE: Симулиране на TWAP поръчка за {symbol} {side}, общо: {total_qty}")

            # Определяме TP/SL базирано на ATR
            atr_value = self._calculate_atr(symbol)

            if atr_value:
                # Използваме ATR за определяне на TP/SL
                if side == 'Buy':
                    tp_price = current_price + (atr_value * 3.0)
                    sl_price = current_price - (atr_value * 1.5)
                else:  # Sell
                    tp_price = current_price - (atr_value * 3.0)
                    sl_price = current_price + (atr_value * 1.5)
            else:
                # Стандартни проценти
                if side == 'Buy':
                    tp_price = current_price * 1.02
                    sl_price = current_price * 0.99
                else:  # Sell
                    tp_price = current_price * 0.98
                    sl_price = current_price * 1.01

            # Закръгляме според изискванията
            tp_price = self.round_price(symbol, tp_price)
            sl_price = self.round_price(symbol, sl_price)

            # Запазваме детайли за позицията
            self.open_positions[symbol] = {
                'side': side,
                'entry_price': current_price,
                'tp': tp_price,
                'sl': sl_price,
                'original_sl': sl_price,
                'atr': atr_value,
                'risk_reward': abs(tp_price - current_price) / abs(current_price - sl_price) if abs(current_price - sl_price) > 0 else 0,
                'trailing_sl_active': False
            }

            # Изпращаме известие
            msg = (f"🔄 TEST MODE: TWAP поръчка за {symbol} {side}\n"
                   f"Общ обем: {total_qty:.4f}\n"
                   f"Средна цена: {current_price:.4f}\n"
                   f"TP: {tp_price:.4f}, SL: {sl_price:.4f}\n"
                   f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            self.send_telegram(msg)
            return

        # В реален режим: TWAP стратегия - разделяме обема на интервали от време

        # TWAP конфигурация
        twap_interval_seconds = 120  # Секунди между поръчките (2 минути)
        num_intervals = 5  # Брой интервали (общо 10 минути)

        chunk_size = total_qty / num_intervals
        chunk_size = self.round_qty(symbol, chunk_size)

        if chunk_size <= 0:
            logging.warning(f"Размерът на поръчката е твърде малък за TWAP: {total_qty}")
            return self.execute_trade(symbol, side)

        # Получаваме правилната категория
        category = 'linear'

        try:
            # Изчисляваме ATR за по-прецизно TP/SL
            atr_value = self._calculate_atr(symbol)

            if atr_value:
                # Използваме ATR за определяне на TP/SL
                if side == 'Buy':
                    tp_price = current_price + (atr_value * 3.0)
                    sl_price = current_price - (atr_value * 1.5)
                else:  # Sell
                    tp_price = current_price - (atr_value * 3.0)
                    sl_price = current_price + (atr_value * 1.5)
            else:
                # Стандартни проценти
                if side == 'Buy':
                    tp_price = current_price * 1.02
                    sl_price = current_price * 0.99
                else:  # Sell
                    tp_price = current_price * 0.98
                    sl_price = current_price * 1.01

            # Закръгляме според изискванията
            tp_price = self.round_price(symbol, tp_price)
            sl_price = self.round_price(symbol, sl_price)

            # Стартираме асинхронен процес за изпълнение на TWAP поръчката
            # В реална имплементация бихме използвали threading или asyncio
            # За простота, тук използваме синхронен подход

            successful_orders = 0
            total_filled_qty = 0
            avg_price = 0

            # Изпращаме info че започваме TWAP
            logging.info(f"Започваме TWAP за {symbol} {side}, общо: {total_qty}, интервали: {num_intervals}")
            self.send_telegram(f"⏱️ Стартиране на TWAP поръчка за {symbol} {side}\nОбщо: {total_qty:.4f} на {num_intervals} части\nИнтервал: {twap_interval_seconds} сек.")

            # Изпълняваме частите през определени интервали
            for i in range(num_intervals):
                # Последната част може да е по-малка, за да компенсира закръглянията
                if i == num_intervals - 1:
                    remaining_qty = total_qty - total_filled_qty
                    if remaining_qty <= 0:
                        break
                    current_chunk = self.round_qty(symbol, remaining_qty)
                else:
                    current_chunk = chunk_size

                # Пропускаме малки количества
                if current_chunk <= 0:
                    continue

                # Изпълняваме частта
                resp = self.session.place_order(
                    category=category,
                    symbol=symbol,
                    side=side,
                    orderType='Market',
                    qty=str(current_chunk),
                    positionIdx=0,
                    timeInForce='GoodTillCancel'
                )

                if resp.get('retCode') == 0:
                    successful_orders += 1
                    total_filled_qty += current_chunk

                    # Опитваме се да получим цената на изпълнение
                    try:
                        order_id = resp.get('result', {}).get('orderId')
                        if order_id:
                            order_info = self.session.get_order_history(
                                category=category,
                                symbol=symbol,
                                orderId=order_id
                            )
                            if order_info.get('retCode') == 0:
                                order_data = order_info.get('result', {}).get('list', [{}])[0]
                                exec_price = float(order_data.get('avgPrice', current_price))
                                avg_price = (avg_price * (successful_orders - 1) + exec_price) / successful_orders
                    except Exception as e:
                        logging.warning(f"Не може да се получи цена на изпълнение: {e}")
                        # Използваме текущата цена като приближение
                        avg_price = (avg_price * (successful_orders - 1) + current_price) / successful_orders

                    # Информация за прогреса
                    logging.info(f"TWAP прогрес: {i+1}/{num_intervals} за {symbol}, изпълнено: {current_chunk:.4f}")
                else:
                    logging.error(f"Грешка при изпълнение на част от TWAP поръчка: {resp.get('retMsg')}")

                # Изчакваме интервала преди следващата част (без последната)
                if i < num_intervals - 1:
                    time.sleep(twap_interval_seconds)

            # Ако поне една поръчка е успешна, задаваме TP/SL за позицията
            if successful_orders > 0:
                # Използваме средната цена на изпълнение, ако е налична
                if avg_price <= 0:
                    avg_price = current_price

                # Задаваме TP/SL за позицията
                tp_sl_resp = self.session.set_trading_stop(
                    category=category,
                    symbol=symbol,
                    takeProfit=str(tp_price),
                    stopLoss=str(sl_price),
                    positionIdx=0
                )

                if tp_sl_resp.get('retCode') != 0:
                    logging.error(f"Грешка при задаване на TP/SL: {tp_sl_resp.get('retMsg')}")

                # Запазваме детайли за позицията
                self.open_positions[symbol] = {
                    'side': side,
                    'entry_price': avg_price,
                    'tp': tp_price,
                    'sl': sl_price,
                    'original_sl': sl_price,
                    'atr': atr_value,
                    'risk_reward': abs(tp_price - avg_price) / abs(avg_price - sl_price) if abs(avg_price - sl_price) > 0 else 0,
                    'trailing_sl_active': False,
                    'open_time': datetime.now()
                }

                # Изпращаме известие
                msg = (f"🚀 TWAP {side} позиция на {symbol} завършена\n"
                       f"Изпълнени части: {successful_orders}/{num_intervals}\n"
                       f"Общо количество: {total_filled_qty:.4f}\n"
                       f"Средна цена: {avg_price:.4f}\n"
                       f"TP: {tp_price:.4f}, SL: {sl_price:.4f}\n"
                       f"Време: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                self.send_telegram(msg)

                return True
            else:
                logging.error(f"Неуспешно изпълнение на TWAP поръчка за {symbol}")
                return False

        except Exception as e:
            logging.error(f"Грешка при изпълнение на TWAP поръчка: {e}")
            return False

    def _execute_vwap_order(self, symbol, side, total_qty, current_price):
        """
        Изпълнява VWAP (Volume-Weighted Average Price) поръчка,
        разпределяйки обема според пазарната активност.
        """
        if self.test_mode:
            logging.info(f"TEST MODE: Симулиране на VWAP поръчка за {symbol} {side}, общо: {total_qty}")

            # Определяме TP/SL базирано на ATR
            atr_value = self._calculate_atr(symbol)

            if atr_value:
                # Използваме ATR за определяне на TP/SL
                if side == 'Buy':
                    tp_price = current_price + (atr_value * 3.0)
                    sl_price = current_price - (atr_value * 1.5)
                else:  # Sell
                    tp_price = current_price - (atr_value * 3.0)
                    sl_price = current_price + (atr_value * 1.5)
            else:
                # Стандартни проценти
                if side == 'Buy':
                    tp_price = current_price * 1.02
                    sl_price = current_price * 0.99
                else:  # Sell
                    tp_price = current_price * 0.98
                    sl_price = current_price * 1.01

            # Закръгляме според изискванията
            tp_price = self.round_price(symbol, tp_price)
            sl_price = self.round_price(symbol, sl_price)

            # Запазваме детайли за позицията
            self.open_positions[symbol] = {
                'side': side,
                'entry_price': current_price,
                'tp': tp_price,
                'sl': sl_price,
                'original_sl': sl_price,
                'atr': atr_value,
                'risk_reward': abs(tp_price - current_price) / abs(current_price - sl_price) if abs(current_price - sl_price) > 0 else 0,
                'trailing_sl_active': False
            }

            # Изпращаме известие
            msg = (f"🔄 TEST MODE: VWAP поръчка за {symbol} {side}\n"
                   f"Общ обем: {total_qty:.4f}\n"
                   f"Средна цена: {current_price:.4f}\n"
                   f"TP: {tp_price:.4f}, SL: {sl_price:.4f}\n"
                   f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            self.send_telegram(msg)
            return

        # В реален режим: VWAP стратегия - разпределяме обема според пазарната активност

        # VWAP конфигурация
        num_intervals = 4  # Брой интервали
        interval_minutes = 3  # Минути между интервалите

        # Анализираме историческия обем, за да разпределим поръчките
        try:
            # Получаваме информация за обемите от последните 15-минутни свещи
            resp = requests.get(f"{self.base_url}/v5/market/kline?category=linear&symbol={symbol}&interval=15&limit=24", timeout=5)
            volume_data = resp.json()

            if volume_data.get('retCode') != 0 or not volume_data.get('result', {}).get('list'):
                logging.warning(f"Не може да се получи информация за обемите за {symbol}, използваме равномерно разпределение")
                # Равномерно разпределение
                volume_weights = [1/num_intervals] * num_intervals
            else:
                # Получаваме обемите от свещите (последните 24 часа)
                candles = volume_data.get('result', {}).get('list', [])
                volumes = []

                for c in candles:
                    if isinstance(c, list) and len(c) >= 6:  # v5 API format
                        volumes.append(float(c[5]))  # volume is at index 5
                    elif isinstance(c, dict) and 'volume' in c:  # old format
                        volumes.append(float(c['volume']))

                if not volumes:
                    # Резервен вариант при липса на данни
                    volume_weights = [1/num_intervals] * num_intervals
                else:
                    # Анализираме обемите по време от деня
                    hours_in_day = [int(datetime.fromtimestamp(int(c[0]) / 1000).hour) if isinstance(c, list) else 
                                  int(datetime.fromtimestamp(int(c.get('openTime', 0)) / 1000).hour) 
                                  for c in candles]

                    # Групираме обемите по часове
                    hour_volumes = {}
                    for i, hour in enumerate(hours_in_day):
                        if hour not in hour_volumes:
                            hour_volumes[hour] = []
                        hour_volumes[hour].append(volumes[i])

                    # Изчисляваме средните обеми по часове
                    avg_hour_volumes = {h: sum(v)/len(v) for h, v in hour_volumes.items()}

                    # Получаваме текущия час
                    current_hour = datetime.now().hour

                    # Прогнозираме обемите за следващите интервали
                    future_volumes = []
                    for i in range(num_intervals):
                        future_hour = (current_hour + i * (interval_minutes // 60)) % 24
                        # Използваме най-близкия наличен час, ако нямаме точния
                        nearest_hour = min(avg_hour_volumes.keys(), key=lambda x: abs(x - future_hour)) if avg_hour_volumes else current_hour
                        future_volumes.append(avg_hour_volumes.get(nearest_hour, 1))

                    # Изчисляваме тегла за разпределение на обема
                    total_future_volume = sum(future_volumes)
                    volume_weights = [v / total_future_volume for v in future_volumes] if total_future_volume > 0 else [1/num_intervals] * num_intervals

            # Изчисляваме ATR за по-прецизно TP/SL
            atr_value = self._calculate_atr(symbol)

            if atr_value:
                # Използваме ATR за определяне на TP/SL
                if side == 'Buy':
                    tp_price = current_price + (atr_value * 3.0)
                    sl_price = current_price - (atr_value * 1.5)
                else:  # Sell
                    tp_price = current_price - (atr_value * 3.0)
                    sl_price = current_price + (atr_value * 1.5)
            else:
                # Стандартни проценти
                if side == 'Buy':
                    tp_price = current_price * 1.02
                    sl_price = current_price * 0.99
                else:  # Sell
                    tp_price = current_price * 0.98
                    sl_price = current_price * 1.01

            # Закръгляме според изискванията
            tp_price = self.round_price(symbol, tp_price)
            sl_price = self.round_price(symbol, sl_price)

            # Получаваме правилната категория
            category = 'linear'

            # Изпращаме info че започваме VWAP
            logging.info(f"Започваме VWAP за {symbol} {side}, общо: {total_qty}, интервали: {num_intervals}")

            # Изчисляваме количества за всеки интервал според теглата
            chunk_sizes = [self.round_qty(symbol, total_qty * weight) for weight in volume_weights]

            # Log разпределението
            distribution_info = ", ".join([f"{i+1}: {size:.4f} ({weight:.1%})" for i, (size, weight) in enumerate(zip(chunk_sizes, volume_weights))])
            self.send_telegram(f"📊 Стартиране на VWAP поръчка за {symbol} {side}\nОбщо: {total_qty:.4f}\nРазпределение: {distribution_info}\nИнтервал: {interval_minutes} мин.")

            # Изпълняваме частите през определени интервали
            successful_orders = 0
            total_filled_qty = 0
            avg_price = 0

            for i, chunk_size in enumerate(chunk_sizes):
                # Пропускаме малки количества
                if chunk_size <= 0:
                    continue

                # Изпълняваме частта
                resp = self.session.place_order(
                    category=category,
                    symbol=symbol,
                    side=side,
                    orderType='Market',
                    qty=str(chunk_size),
                    positionIdx=0,
                    timeInForce='GoodTillCancel'
                )

                if resp.get('retCode') == 0:
                    successful_orders += 1
                    total_filled_qty += chunk_size

                    # Опитваме се да получим цената на изпълнение
                    try:
                        order_id = resp.get('result', {}).get('orderId')
                        if order_id:
                            order_info = self.session.get_order_history(
                                category=category,
                                symbol=symbol,
                                orderId=order_id
                            )
                            if order_info.get('retCode') == 0:
                                order_data = order_info.get('result', {}).get('list', [{}])[0]
                                exec_price = float(order_data.get('avgPrice', current_price))
                                avg_price = (avg_price * (successful_orders - 1) + exec_price) / successful_orders
                    except Exception as e:
                        logging.warning(f"Не може да се получи цена на изпълнение: {e}")
                        # Използваме текущата цена като приближение
                        avg_price = (avg_price * (successful_orders - 1) + current_price) / successful_orders

                    # Информация за прогреса
                    logging.info(f"VWAP прогрес: {i+1}/{len(chunk_sizes)} за {symbol}, изпълнено: {chunk_size:.4f}")
                else:
                    logging.error(f"Грешка при изпълнение на част от VWAP поръчка: {resp.get('retMsg')}")

                # Изчакваме интервала преди следващата част (без последната)
                if i < len(chunk_sizes) - 1:
                    time.sleep(interval_minutes * 60)

            # Ако поне една поръчка е успешна, задаваме TP/SL за позицията
            if successful_orders > 0:
                # Използваме средната цена на изпълнение, ако е налична
                if avg_price <= 0:
                    avg_price = current_price

                # Задаваме TP/SL за позицията
                tp_sl_resp = self.session.set_trading_stop(
                    category=category,
                    symbol=symbol,
                    takeProfit=str(tp_price),
                    stopLoss=str(sl_price),
                    positionIdx=0
                )

                if tp_sl_resp.get('retCode') != 0:
                    logging.error(f"Грешка при задаване на TP/SL: {tp_sl_resp.get('retMsg')}")

                # Запазваме детайли за позицията
                self.open_positions[symbol] = {
                    'side': side,
                    'entry_price': avg_price,
                    'tp': tp_price,
                    'sl': sl_price,
                    'original_sl': sl_price,
                    'atr': atr_value,
                    'risk_reward': abs(tp_price - avg_price) / abs(avg_price - sl_price) if abs(avg_price - sl_price) > 0 else 0,
                    'trailing_sl_active': False,
                    'open_time': datetime.now()
                }

                # Изпращаме известие
                msg = (f"🚀 VWAP {side} позиция на {symbol} завършена\n"
                       f"Изпълнени части: {successful_orders}/{len(chunk_sizes)}\n"
                       f"Общо количество: {total_filled_qty:.4f}\n"
                       f"Средна цена: {avg_price:.4f}\n"
                       f"TP: {tp_price:.4f}, SL: {sl_price:.4f}\n"
                       f"Време: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                self.send_telegram(msg)

                return True
            else:
                logging.error(f"Неуспешно изпълнение на VWAP поръчка за {symbol}")
                return False

        except Exception as e:
            logging.error(f"Грешка при изпълнение на VWAP поръчка: {e}")
            return False

    def calculate_ema(self, prices, period):
        """
        Изчислява Exponential Moving Average (EMA).

        Args:
            prices (list): Списък с цените
            period (int): Период за изчисление на EMA

        Returns:
            float: Изчислената EMA стойност
        """
        if len(prices) < period:
            return None

        import numpy as np
        prices_array = np.array(prices)

        # Изчисляваме първата стойност като SMA
        sma = np.mean(prices_array[:period])

        # Ако имаме само точно периода, връщаме SMA
        if len(prices) == period:
            return sma

        # Тегло за EMA
        multiplier = 2 / (period + 1)

        # Векторизирано изчисление на EMA
        ema = np.zeros_like(prices_array, dtype=float)
        ema[:period] = sma

        for i in range(period, len(prices_array)):
            ema[i] = (prices_array[i] - ema[i-1]) * multiplier + ema[i-1]

        return ema[-1]
    
    def calculate_rsi(self, prices, period=14):
        """
        Изчислява RSI (Relative Strength Index) за даден масив от цени и период.
        
        Args:
            prices (list): Списък с цени
            period (int): Период за изчисление на RSI (по подразбиране 14)
            
        Returns:
            float: Изчисленият RSI (стойност между 0 и 100)
        """
        if len(prices) < period + 1:
            return 50  # Неутрална стойност при липса на данни
        
        # Изчисляваме промените в цената
        deltas = [prices[i] - prices[i-1] for i in range(1, len(prices))]
        
        # Разделяме печалби и загуби
        gains = [delta if delta > 0 else 0 for delta in deltas]
        losses = [-delta if delta < 0 else 0 for delta in deltas]
        
        # Първоначална средна печалба и загуба
        avg_gain = sum(gains[:period]) / period
        avg_loss = sum(losses[:period]) / period
        
        # Изчисляваме RSI
        for i in range(period, len(deltas)):
            avg_gain = (avg_gain * (period - 1) + gains[i]) / period
            avg_loss = (avg_loss * (period - 1) + losses[i]) / period
        
        if avg_loss == 0:
            return 100
        
        rs = avg_gain / avg_loss
        rsi = 100 - (100 / (1 + rs))
        
        return rsi

    def _calculate_atr(self, symbol):
        """Изчислява ATR (Average True Range) за по-прецизно определяне на TP/SL.
        Оптимизирана версия с използване на кеширани данни."""
        try:
            # Инициализираме ATR кеш, ако не съществува
            if not hasattr(self, 'atr_cache'):
                self.atr_cache = {}
                
            if not hasattr(self, 'atr_cache_time'):
                self.atr_cache_time = {}
                
            current_time = time.time()
            cache_ttl = 600  # Кеширане за 10 минути
            
            # Проверяваме за наличие на кеширана ATR стойност, която е валидна
            if (symbol in self.atr_cache and symbol in self.atr_cache_time and
                    current_time - self.atr_cache_time.get(symbol, 0) < cache_ttl):
                return self.atr_cache[symbol]
                
            # Първо проверяваме дали имаме кеширани candles_15m данни
            if (hasattr(self, 'candles_cache') and symbol in self.candles_cache and 
                    'candles_15m' in self.candles_cache[symbol] and 
                    self.candles_cache[symbol]['candles_15m']):
                candles = self.candles_cache[symbol]['candles_15m']
            else:
                # Ако нямаме кеширани данни, извличаме ги
                resp = requests.get(f"{self.base_url}/v5/market/kline?category=linear&symbol={symbol}&interval=15&limit=20", timeout=5)
                result = resp.json().get('result', {})
                candles = result.get('list', [])

            if candles and len(candles) >= 14:
                # Calculate ATR using NumPy for better performance
                import numpy as np

                # Extract price data
                highs = np.array([float(c[2]) for c in candles if isinstance(c, list) and len(c) >= 5])
                lows = np.array([float(c[3]) for c in candles if isinstance(c, list) and len(c) >= 5])
                closes = np.array([float(c[4]) for c in candles if isinstance(c, list) and len(c) >= 5])

                if len(highs) < 14:
                    return None

                # Calculate true ranges using vectorized operations
                true_ranges = np.zeros(len(highs))
                true_ranges[0] = highs[0] - lows[0]  # First TR value

                # Vectorized calculation for remaining values
                high_low = highs[1:] - lows[1:]
                high_pc = np.abs(highs[1:] - closes[:-1])
                low_pc = np.abs(lows[1:] - closes[:-1])

                # Get max of the three calculations
                true_ranges[1:] = np.maximum(np.maximum(high_low, high_pc), low_pc)

                # Calculate ATR as average of last 14 true ranges
                atr_value = np.mean(true_ranges[-14:])
                
                # Запазваме в кеша
                self.atr_cache[symbol] = atr_value
                self.atr_cache_time[symbol] = current_time
                
                # Почистваме кеша, ако е станал твърде голям
                if len(self.atr_cache) > 100:
                    # Намираме най-старите записи
                    oldest_symbols = sorted(self.atr_cache_time.items(), key=lambda x: x[1])[:20]
                    for old_symbol, _ in oldest_symbols:
                        if old_symbol in self.atr_cache:
                            del self.atr_cache[old_symbol]
                        if old_symbol in self.atr_cache_time:
                            del self.atr_cache_time[old_symbol]
                
                return atr_value

            return None
        except Exception as e:
            logging.error(f"Грешка при изчисляване на ATR: {e}")
            return None

    def execute_trade(self, symbol, signal):
        """Изпълнява сделка (пазарна поръчка с TP/SL) за дадения символ според сигнала."""
        side = 'Buy' if signal == 'Buy' else 'Sell'

        # In test mode, simulate the trade without actually making API calls
        if self.test_mode:
            entry_price = 0
            try:
                # Try to get the price through a public API endpoint
                resp = requests.get(f"{self.base_url}/v5/market/tickers?category=linear&symbol={symbol}", timeout=5)
                data = resp.json()
                if data.get('retCode') == 0 and data.get('result', {}).get('list'):
                    entry_price = float(data['result']['list'][0]['lastPrice'])
            except Exception as e:
                logging.warning(f"Cannot get price in test mode: {e}")
                entry_price = 100.0  # default test price

            # Изчисляваме ATR за по-прецизно определяне на TP/SL нива
            atr_value = None
            try:
                # Get historical candles for ATR calculation
                resp = requests.get(f"{self.base_url}/v5/market/kline?category=linear&symbol={symbol}&interval=15&limit=20", timeout=5)
                result = resp.json().get('result', {})
                candles = result.get('list', [])

                if candles and len(candles) >= 14:
                    # Calculate ATR
                    highs = []
                    lows = []
                    closes = []

                    for c in candles:
                        if isinstance(c, list) and len(c) >= 5:  # v5 API format
                            highs.append(float(c[2]))  # high is at index 2
                            lows.append(float(c[3]))   # low is at index 3
                            closes.append(float(c[4])) # close is at index 4

                    # Calculate true ranges
                    true_ranges = []
                    true_ranges.append(highs[0] - lows[0])  # First TR value

                    for i in range(1, len(highs)):
                        tr1 = highs[i] - lows[i]
                        tr2 = abs(highs[i] - closes[i-1])
                        tr3 = abs(lows[i] - closes[i-1])
                        true_ranges.append(max(tr1, tr2, tr3))

                    # Calculate ATR as average of last 14 true ranges
                    atr_value = sum(true_ranges[-14:]) / 14
            except Exception as e:
                logging.warning(f"Cannot calculate ATR in test mode: {e}")

            # Подобрено динамично определяне на TP и SL базирано на ATR
            if atr_value:
                # Използваме гъвкави множители на ATR за определяне на TP/SL според волатилността
                # Изчисляваме ATR като процент от цената за оценка на волатилността
                atr_percent = (atr_value / entry_price) * 100 if entry_price > 0 else 0
                
                # Динамично определяне на множителите базирани на волатилността
                # По-висока волатилност = по-широки стопове
                if atr_percent > 1.5:  # Много висока волатилност
                    atr_sl_multiplier = 2.0  # По-широк SL за висока волатилност
                    atr_tp_multiplier = 4.0  # По-широк TP за висока волатилност
                elif atr_percent > 0.8:  # Нормална волатилност
                    atr_sl_multiplier = 1.5
                    atr_tp_multiplier = 3.0
                else:  # Ниска волатилност
                    atr_sl_multiplier = 1.2  # По-тесен SL за ниска волатилност
                    atr_tp_multiplier = 2.5  # По-тесен TP за ниска волатилност

                if side == 'Buy':
                    sl_price = entry_price - (atr_value * atr_sl_multiplier)
                    tp_price = entry_price + (atr_value * atr_tp_multiplier)
                else:  # Sell
                    sl_price = entry_price + (atr_value * atr_sl_multiplier)
                    tp_price = entry_price - (atr_value * atr_tp_multiplier)
                
                # Добавяме информация за волатилността в логовете
                logging.info(f"Волатилност за {symbol}: ATR = {atr_value:.6f}, ATR% = {atr_percent:.2f}%, SL множител = {atr_sl_multiplier}, TP множител = {atr_tp_multiplier}")
            else:
                # Резервен метод, ако не може да се изчисли ATR
                # Ensure minimum distance between entry and SL (at least 1% of entry price)
                min_distance = entry_price * 0.01

                if side == 'Buy':
                    tp_price = entry_price * 1.02  # TP 2% above entry
                    sl_price = entry_price * 0.99  # SL 1% below entry

                    # Ensure SL is at least min_distance away from entry
                    if entry_price - sl_price < min_distance:
                        sl_price = entry_price - min_distance
                else:  # Sell
                    tp_price = entry_price * 0.98  # TP 2% below entry
                    sl_price = entry_price * 1.01  # SL 1% above entry

                    # Ensure SL is at least min_distance away from entry
                    if sl_price - entry_price < min_distance:
                        sl_price = entry_price + min_distance

            # Calculate risk:reward ratio
            risk = abs(entry_price - sl_price)
            reward = abs(entry_price - tp_price)
            risk_reward_ratio = reward / risk if risk > 0 else 0

            # Apply proper rounding for the simulated trades as well
            sl_price = self.round_price(symbol, sl_price)
            tp_price = self.round_price(symbol, tp_price)

            # Динамично изчисляване на размера според риска
            # Use balance-based position sizing with ATR-adjusted risk
            if atr_value and self.balance > 0:
                # Определяме максималната загуба в долари, която сме готови да поемем
                max_risk_amount = self.balance * self.risk_percent
                
                # Изчисляваме възможна загуба на контракт (от entry до SL)
                risk_per_contract = abs(entry_price - sl_price)
                
                if risk_per_contract > 0:
                    # Изчисляваме количеството според риска
                    qty = max_risk_amount / risk_per_contract
                    # Закръгляме количеството
                    qty = self.round_qty(symbol, qty)
                else:
                    qty = 10.0  # Резервен вариант
            else:
                qty = 10.0  # sample quantity for test mode

            logging.info(f"TEST MODE: Simulated {side} order for {symbol}: price {entry_price}, qty {qty}, TP {tp_price}, SL {sl_price}, R:R {risk_reward_ratio:.2f}")

            # Save position details for simulation with ATR value
            self.open_positions[symbol] = {
                'side': side,
                'entry_price': entry_price,
                'tp': tp_price,
                'sl': sl_price,
                'original_sl': sl_price,  # Запазваме оригиналния SL за trailing stop loss
                'atr': atr_value,
                'risk_reward': risk_reward_ratio,
                'trailing_sl_active': False,  # Флаг за активен trailing stop loss
                'trailing_activated_price': 0,  # Цена, при която е активиран trailing
                'trailing_activation_threshold': 0.5  # Активиране на trailing след 0.5% печалба
            }

            # Send Telegram notification with ATR info
            msg = (f"🔄 TEST MODE: Simulated {side} position on {symbol}\n"
                   f"Entry: {entry_price:.4f}, TP: {tp_price:.4f}, SL: {sl_price:.4f}\n"
                   f"ATR: {atr_value:.6f}, Risk:Reward = 1:{risk_reward_ratio:.2f}\n"
                   f"Quantity: {qty:.4f}\n"
                   f"Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            self.send_telegram(msg)
            return

        # For real trading mode - proceed with normal execution
        # Изчисляваме количество според риск процент от текущия баланс
        self.update_balance()
        if self.balance <= 0:
            logging.error("Няма наличен баланс, прекратяване на изпълнението на сделката.")
            return

        # Проверка за минимален баланс преди търговия
        min_balance_required = 10.0  # Минимален баланс от 10 USDT
        if self.balance < min_balance_required:
            logging.warning(f"Балансът ({self.balance:.2f} USDT) е под минималния ({min_balance_required} USDT), прекратяване на сделката.")
            return

        # Адаптивен риск процент според баланса - по-малък риск при малък баланс
        adaptive_risk = self.risk_percent
        if self.balance < 100:
            adaptive_risk = self.risk_percent * 0.5  # Намаляваме риска наполовина
            logging.info(f"Адаптивен риск: {adaptive_risk:.2%} поради малък баланс")

        # Ограничаваме максималната стойност на позицията
        position_value = self.balance * adaptive_risk  # стойност на позицията в USDT
        
        # Проверяваме дали стойността на позицията не е твърде малка
        if position_value < 5.0:
            # Ако балансът е малък, ограничаваме максималния процент от баланса
            max_safe_percentage = 0.2  # Максимум 20% от баланса
            safe_position_value = min(5.0, self.balance * max_safe_percentage)
            
            if safe_position_value < 5.0:
                logging.warning(f"Стойността на позицията ({position_value:.2f} USDT) е под минималната (5 USDT), но балансът е твърде малък. Използваме безопасна стойност: {safe_position_value:.2f} USDT")
                position_value = safe_position_value
            else:
                position_value = 5.0
                logging.info(f"Стойността на позицията увеличена до минималните 5 USDT за спазване на изискванията на борсата")

        # Определяме правилната категория за символа
        category = 'linear'
        if 'PERP' in symbol:
            category = 'inverse'
            logging.info(f"Символ {symbol} е inverse перпетуален, използва се категория 'inverse'")

        # Вземаме текущата последна цена (необходима за изчисляване на количеството)
        price = None
        try:
            ticker = self.session.get_tickers(category=category, symbol=symbol)
            if ticker.get('retCode') == 0 and ticker['result']['list']:
                price = float(ticker['result']['list'][0]['lastPrice'])
        except Exception as e:
            logging.error(f"Грешка при взимане на цена за {symbol} (категория {category}): {e}")

        if price is None:
            # алтернативно: публичен тикер
            try:
                resp = requests.get(f"{self.base_url}/v5/market/tickers?category={category}&symbol={symbol}", timeout=5)
                data = resp.json()
                if data.get('retCode') == 0 and data.get('result', {}).get('list'):
                    price = float(data['result']['list'][0]['lastPrice'])
            except Exception as e:
                logging.error(f"Не може да се определи цена за {symbol}, сделката се пропуска: {e}")
                return

        if price is None or price <= 0:
            logging.error(f"Невалидна цена ({price}) за {symbol}, сделката се пропуска.")
            return

        entry_price = price  # приблизителна входна цена (близка до пазарната)

        # Изчисляваме ATR за по-прецизно определяне на TP/SL нива
        atr_value = None
        try:
            # Get historical candles for ATR calculation
            resp = requests.get(f"{self.base_url}/v5/market/kline?category={category}&symbol={symbol}&interval=15&limit=20", timeout=5)
            result = resp.json().get('result', {})
            candles = result.get('list', [])

            if candles and len(candles) >= 14:
                # Calculate ATR
                highs = []
                lows = []
                closes = []

                for c in candles:
                    if isinstance(c, list) and len(c) >= 5:  # v5 API format
                        highs.append(float(c[2]))  # high is at index 2
                        lows.append(float(c[3]))   # low is at index 3
                        closes.append(float(c[4])) # close is at index 4

                # Calculate true ranges
                true_ranges = []
                true_ranges.append(highs[0] - lows[0])  # First TR value

                for i in range(1, len(highs)):
                    tr1 = highs[i] - lows[i]
                    tr2 = abs(highs[i] - closes[i-1])
                    tr3 = abs(lows[i] - closes[i-1])
                    true_ranges.append(max(tr1, tr2, tr3))

                # Calculate ATR as average of last 14 true ranges
                atr_value = sum(true_ranges[-14:]) / 14
        except Exception as e:
            logging.error(f"Грешка при изчисляване на ATR за {symbol}: {e}")

        # Подобрено динамично определяне на TP и SL базирано на ATR с адаптация към волатилността
        if atr_value:
            # Изчисляваме ATR като процент от цената за оценка на волатилността
            atr_percent = (atr_value / entry_price) * 100 if entry_price > 0 else 0
            
            # Динамично определяне на множителите базирани на волатилността
            if atr_percent > 1.5:  # Много висока волатилност
                atr_sl_multiplier = 2.0  # По-широк SL за висока волатилност
                atr_tp_multiplier = 4.0  # По-широк TP за висока волатилност
            elif atr_percent > 0.8:  # Нормална волатилност
                atr_sl_multiplier = 1.5
                atr_tp_multiplier = 3.0
            else:  # Ниска волатилност
                atr_sl_multiplier = 1.2  # По-тесен SL за ниска волатилност
                atr_tp_multiplier = 2.5  # По-тесен TP за ниска волатилност

            if side == 'Buy':
                sl_price = entry_price - (atr_value * atr_sl_multiplier)
                tp_price = entry_price + (atr_value * atr_tp_multiplier)
            else:  # Sell
                sl_price = entry_price + (atr_value * atr_sl_multiplier)
                tp_price = entry_price - (atr_value * atr_tp_multiplier)
            
            # Добавяме информация за волатилността в логовете
            logging.info(f"Волатилност за {symbol}: ATR = {atr_value:.6f}, ATR% = {atr_percent:.2f}%, SL множител = {atr_sl_multiplier}, TP множител = {atr_tp_multiplier}")

            # Проверка за разумни стойности на TP/SL
            # Минимум 0.5% разлика между entry и SL
            min_sl_distance = entry_price * 0.005
            # Изчисляваме максимална дистанция базирана на ATR, но не повече от 5%
            max_sl_distance = min(entry_price * 0.05, atr_value * 2.5)

            if side == 'Buy':
                if entry_price - sl_price < min_sl_distance:
                    sl_price = entry_price - min_sl_distance
                elif entry_price - sl_price > max_sl_distance:
                    sl_price = entry_price - max_sl_distance
            else:  # Sell
                if sl_price - entry_price < min_sl_distance:
                    sl_price = entry_price + min_sl_distance
                elif sl_price - entry_price > max_sl_distance:
                    sl_price = entry_price + max_sl_distance
        else:
            # Резервен метод със стандартни проценти, ако не може да се изчисли ATR
            # Динамично определяне на TP и SL (като процент от цената, адаптиран спрямо волатилност)
            sl_pct = 0.01  # базов стоп: 1% от цената
            tp_pct = 0.02  # базов TP: 2% от цената

            # Вземаме краткосрочна волатилност (напр. от 15-мин свещи) за адаптиране на TP/SL
            current_vol = 0
            try:
                # Updated to v5 API
                resp = requests.get(f"{self.base_url}/v5/market/kline?category={category}&symbol={symbol}&interval=15&limit=10", timeout=5)
                result = resp.json().get('result', {})
                candles = result.get('list', [])

                # For v5 API: the candle format is [timestamp, open, high, low, close, volume, turnover]
                closes = []
                for c in candles:
                    if isinstance(c, list) and len(c) >= 5:  # v5 API format
                        closes.append(float(c[4]))  # close is at index 4
                    elif isinstance(c, dict) and 'close' in c:  # old format
                        closes.append(float(c['close']))

                vols = []
                for i in range(1, len(closes)):
                    if closes[i-1] != 0:
                        vols.append(abs(closes[i] - closes[i-1]) / closes[i-1])
                if vols:
                    current_vol = sum(vols) / len(vols)
            except Exception as e:
                logging.error(f"Error calculating volatility for {symbol}: {e}")
                current_vol = 0

            # Адаптация: при висока волатилност увеличаваме TP/SL, при ниска - намаляваме
            if current_vol > 0.01:         # много висока волатилност (~1%+ движение на бар)
                sl_pct = 0.02
                tp_pct = 0.04
            elif current_vol < 0.003:     # ниска волатилност
                sl_pct = 0.005
                tp_pct = 0.01

            # Определяме конкретни нива за TP и SL в зависимост от посоката на сделката
            if side == 'Buy':
                sl_price = entry_price * (1 - sl_pct)
                tp_price = entry_price * (1 + tp_pct)
            else:  # Sell
                sl_price = entry_price * (1 + sl_pct)
                tp_price = entry_price * (1 - tp_pct)

        # Изчисляваме Risk:Reward съотношение
        risk = abs(entry_price - sl_price)
        reward = abs(entry_price - tp_price)
        risk_reward_ratio = reward / risk if risk > 0 else 0

        # Проверка за минимално R:R съотношение
        min_risk_reward = 1.5  # Минимално 1.5:1 risk:reward съотношение

        if risk_reward_ratio < min_risk_reward:
            # Коригираме TP, за да постигнем желаното R:R съотношение
            if side == 'Buy':
                tp_price = entry_price + (min_risk_reward * risk)
            else:  # Sell
                tp_price = entry_price - (min_risk_reward * risk)

        # Закръгляме TP и SL до подходящи стойности според tickSize
        sl_price = self.round_price(symbol, sl_price)
        tp_price = self.round_price(symbol, tp_price)

        # Проверяваме дали TP и SL са валидни числа
        if not (sl_price > 0 and tp_price > 0):
            logging.error(f"Невалидни TP ({tp_price}) или SL ({sl_price}) стойности за {symbol}, сделката се пропуска.")
            return

        # Изчисляваме размера на позицията на база допустимата загуба при достигане на SL
        max_loss_amount = position_value  # максимална загуба в USDT
        risk_per_contract = abs(entry_price - sl_price)

        if risk_per_contract > 0:
            # Вместо фиксиран процент, използваме риск-базиран подход
            risk_based_qty = max_loss_amount / risk_per_contract
            qty = min(risk_based_qty, position_value / entry_price)  # избираме по-малкото от двете
        else:
            # Стандартен подход при грешка в изчислението
            qty = position_value / entry_price

        # Закръгляме количеството
        qty = self.round_qty(symbol, qty)

        # Проверка за минимално и максимално количество за символа
        try:
            symbol_info = self.symbols_info.get(symbol, {})
            if symbol_info and 'lotSizeFilter' in symbol_info:
                min_order_qty = float(symbol_info['lotSizeFilter'].get('minOrderQty', 0))
                max_order_qty = float(symbol_info['lotSizeFilter'].get('maxOrderQty', float('inf')))

                if qty < min_order_qty:
                    qty = min_order_qty
                    logging.info(f"Коригирано количество за {symbol} до минималното: {qty}")

                if qty > max_order_qty:
                    qty = max_order_qty
                    logging.info(f"Коригирано количество за {symbol} до максималното: {qty}")
        except Exception as e:
            logging.error(f"Грешка при проверка на лимитите за количество за {symbol}: {e}")

        # Задаваме максимално допустимо количество според риска за сметката
        # Не позволяваме позиция > 25% от сметката независимо от минималните изисквания
        max_safe_qty = self.round_qty(symbol, (self.balance * 0.25) / entry_price)
        
        # Проверяваме дали количеството * цената ≥ 5 USDT (минималната стойност за поръчка)
        order_value = qty * entry_price
        if order_value < 5.0:
            # Увеличаваме количеството, за да достигнем минималната стойност, но с лимит
            suggested_qty = self.round_qty(symbol, 5.1 / entry_price)
            
            # Ограничаваме увеличението до безопасното количество
            if suggested_qty > max_safe_qty:
                if max_safe_qty * entry_price >= 5.0:
                    # Ако безопасното количество все пак достига минималната стойност
                    new_qty = max_safe_qty
                    logging.warning(f"Ограничаваме количеството за {symbol} до безопасно ниво: {new_qty} (вместо {suggested_qty})")
                else:
                    # Ако безопасното количество не достига минималната стойност, пропускаме сделката
                    logging.warning(f"Необходимото количество ({suggested_qty}) за {symbol} надвишава безопасния лимит ({max_safe_qty}). Пропускаме сделката.")
                    return
            else:
                new_qty = suggested_qty
                logging.info(f"Коригирано количество за {symbol} от {qty} до {new_qty} за минимална стойност 5 USDT")
            
            qty = new_qty
            # Обновяваме стойността на поръчката
            order_value = qty * entry_price

        if qty <= 0:
            logging.warning(f"Изчисленото количество {qty} за {symbol} е твърде малко, пропускане.")
            return

        # Проверяваме отново стойността на поръчката след всички корекции
        if order_value < 5.0:
            # Опитваме се още веднъж да коригираме с малко по-голям буфер
            new_qty = self.round_qty(symbol, 5.5 / entry_price)
            logging.info(f"Втора корекция на количество за {symbol} от {qty} до {new_qty} за минимална стойност 5 USDT")
            qty = new_qty
            order_value = qty * entry_price
            
            if order_value < 5.0:
                logging.warning(f"Стойността на поръчката ({order_value:.2f} USDT) е под минималната (5 USDT) за {symbol}, пропускане.")
                return

        # Изпращане на пазарна поръчка с зададен TP/SL чрез API
        try:
            # Конвертираме числата до правилния формат
            qty_str = str(qty)
            tp_str = str(tp_price)
            sl_str = str(sl_price)

            # Проверка дали символът е в правилна категория
            symbols_in_category = []
            try:
                instruments = self.session.get_instruments_info(category=category)
                if instruments.get('retCode') == 0:
                    symbols_in_category = [item['symbol'] for item in instruments.get('result', {}).get('list', [])]
            except Exception as e:
                logging.error(f"Грешка при проверка на символи в категория {category}: {e}")

            if symbol not in symbols_in_category and category == 'inverse':
                # Пробваме с linear категория, ако символът не е в inverse
                category = 'linear'
                logging.info(f"Символ {symbol} не е намерен в inverse категория, сменяме на linear")
            elif symbol not in symbols_in_category and category == 'linear':
                # Пробваме с inverse категория, ако символът не е в linear
                category = 'inverse'
                logging.info(f"Символ {symbol} не е намерен в linear категория, сменяме на inverse")

            logging.info(f"Изпращаме поръчка: {symbol} ({category}), {side}, qty: {qty_str}, TP: {tp_str}, SL: {sl_str}")

            order = self.session.place_order(
                category=category,
                symbol=symbol,
                side=side,
                orderType='Market',
                qty=qty_str,
                takeProfit=tp_str,
                stopLoss=sl_str,
                positionIdx=0,  # За едностранна (хеджирана) позиция индексът е 0
                tpslMode='Full',  # пълен TP/SL за цялата позиция
                timeInForce='GoodTillCancel'
            )

            if order.get('retCode') != 0:
                error_message = order.get('retMsg', 'Неизвестна грешка')
                logging.error(f"Неуспешно поставяне на поръчка: {error_message}")
                logging.error(f"Детайли на поръчката: {symbol}, {side}, qty: {qty}, TP: {tp_price}, SL: {sl_price}, стойност: {order_value} USDT")

                # Проверка за конкретни грешки и препоръки за отстраняването им
                if "ErrCode: 110043" in error_message or "position idx not exists" in error_message.lower():
                    logging.info(f"Опитваме отново без positionIdx за {symbol}")
                    # Опитваме отново без positionIdx
                    order = self.session.place_order(
                        category=category,
                        symbol=symbol,
                        side=side,
                        orderType='Market',
                        qty=qty_str,
                        takeProfit=tp_str,
                        stopLoss=sl_str,
                        tpslMode='Full',
                        timeInForce='GoodTillCancel'
                    )

                    if order.get('retCode') == 0:
                        logging.info(f"Успешно изпълнена поръчка при втори опит за {symbol}")
                    else:
                        error_message = order.get('retMsg', 'Неизвестна грешка')
                        logging.error(f"Неуспешна поръчка при втори опит: {error_message}")
                        return
                else:
                    return

            logging.info(f"Placed {side} order for {symbol}: qty {qty}, TP {tp_price}, SL {sl_price}, order value: {order_value} USDT")

            # Запазваме детайли за отворената позиция
            self.open_positions[symbol] = {
                'side': side,
                'entry_price': entry_price,
                'tp': tp_price,
                'sl': sl_price,
                'original_sl': sl_price,  # Запазваме оригиналния SL за trailing stop loss
                'atr': atr_value,
                'risk_reward': risk_reward_ratio,
                'trailing_sl_active': False,  # Флаг за активен trailing stop loss
                'trailing_activated_price': 0,  # Цена, при която е активиран trailing
                'trailing_activation_threshold': 0.5,  # Активиране на trailing след 0.5% печалба
                'open_time': datetime.now()  # Добавяме време на отваряне
            }

            # Изпращаме известие в Telegram за отворената сделка
            msg = (f"🚀 Отворена {side} позиция на {symbol}\n"
                   f"Вход: {entry_price:.4f}, TP: {tp_price:.4f}, SL: {sl_price:.4f}, Количество: {qty:.4f}\n"
                   f"ATR: {atr_value:.6f}, R:R = 1:{risk_reward_ratio:.2f}\n"
                   f"Стойност: {order_value:.2f} USDT\n"
                   f"Време: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            self.send_telegram(msg)

        except Exception as e:
            logging.error(f"Грешка при изпращане на поръчката за {symbol}: {e}")
            # Опитваме да получим повече информация за грешката, ако е възможно
            error_info = str(e)
            if 'json' in error_info.lower():
                try:
                    import json
                    error_data = json.loads(error_info.split("response=")[-1].strip())
                    if isinstance(error_data, dict) and 'retMsg' in error_data:
                        logging.error(f"API грешка за {symbol}: {error_data['retMsg']}")
                except:
                    pass

    def get_position_status(self, symbol, pos):
        """Проверява статуса на отворена позиция (Entry, TP, SL) и изчислява процента печалба/загуба."""
        current_price = None

        # Опитваме да вземем текущата цена за символа
        try:
            if self.test_mode:
                # Get price via public API in test mode
                resp = requests.get(f"{self.base_url}/v5/market/tickers?category=linear&symbol={symbol}", timeout=5)
                data = resp.json()
                if data.get('retCode') == 0 and data.get('result', {}).get('list'):
                    current_price = float(data['result']['list'][0]['lastPrice'])
            else:
                # Use session in real mode
                tick = self.session.get_tickers(category='linear', symbol=symbol)
                if tick.get('retCode') == 0 and tick['result']['list']:
                    current_price = float(tick['result']['list'][0]['lastPrice'])
        except Exception as e:
            logging.error(f"Грешка при взимане на текуща цена за {symbol}: {e}")
            return None, None, 0.0

        if current_price is None:
            return None, None, 0.0

        # Изчисляваме процента печалба/загуба
        entry_price = pos['entry_price']
        profit_pct = 0.0

        if entry_price > 0:
            if pos['side'] == 'Buy':
                profit_pct = (current_price - entry_price) / entry_price * 100
            else:  # Sell
                profit_pct = (entry_price - current_price) / entry_price * 100

        # Определяме дали цената е около Entry, TP или SL
        # Допускаме малко отклонение (0.2% от цената)
        tp = pos['tp']
        sl = pos['sl']
        tolerance = entry_price * 0.002

        # Разширен статус с повече информация
        if pos['side'] == 'Buy':
            # За Buy сделки
            if current_price <= entry_price * (1 + 0.001) and current_price >= entry_price * (1 - 0.001):
                price_status = "Entry"
            elif current_price < sl + tolerance:
                price_status = "Достигнат SL ❌"
            elif current_price > tp - tolerance:
                price_status = "Достигнат TP ✅"
            elif current_price < entry_price:
                # Между entry и SL (в загуба)
                progress_to_sl = (entry_price - current_price) / (entry_price - sl) * 100 if entry_price != sl else 0
                price_status = f"В загуба {progress_to_sl:.1f}% към SL"
            else:
                # Между entry и TP (в печалба)
                progress_to_tp = (current_price - entry_price) / (tp - entry_price) * 100 if tp != entry_price else 0
                price_status = f"В печалба {progress_to_tp:.1f}% към TP"
        else:
            # За Sell сделки
            if current_price <= entry_price * (1 + 0.001) and current_price >= entry_price * (1 - 0.001):
                price_status = "Entry"
            elif current_price > sl - tolerance:
                price_status = "Достигнат SL ❌"
            elif current_price < tp + tolerance:
                price_status = "Достигнат TP ✅"
            elif current_price > entry_price:
                # Между entry и SL (в загуба)
                progress_to_sl = (current_price - entry_price) / (sl - entry_price) * 100 if sl != entry_price else 0
                price_status = f"В загуба {progress_to_sl:.1f}% към SL"
            else:
                # Между entry и TP (в печалба)
                progress_to_tp = (entry_price - current_price) / (entry_price - tp) * 100 if entry_price != tp else 0
                price_status = f"В печалба {progress_to_tp:.1f}% към TP"

        # Оценка на текущия risk:reward
        if 'risk_reward' in pos:
            original_rr = pos['risk_reward']
            current_risk = abs(current_price - sl)
            current_reward = abs(tp - current_price)
            current_rr = current_reward / current_risk if current_risk > 0 else 0

            # Ако текущият R:R се е влошил значително, добавяме това към статуса
            if current_rr < original_rr * 0.5:
                price_status += f" (R:R влошен {current_rr:.1f}:1)"

        return price_status, current_price, profit_pct

    def display_open_positions(self):
        """Показва подробна информация за всички отворени позиции и техния статус с подобрена визуализация."""
        if not self.open_positions:
            return

        # Получаваме текущото време за показване на времетраене на позициите
        current_time = datetime.now()

        # Използваме по-подходящи емоджита за заглавието
        msg = "📊 ТЕКУЩИ АКТИВНИ ПОЗИЦИИ 📊\n"

        # Показваме общата информация за активните позиции
        positions_count = len(self.open_positions)
        max_positions = 5  # Според максималния брой позиции

        # Добавяме дата/час и информация за брой позиции
        msg += f"⏰ {current_time.strftime('%Y-%m-%d %H:%M')}\n"
        msg += f"📈 Активни позиции: {positions_count}/{max_positions}\n\n"

        # Сортираме позициите по печалба за по-добра визуализация
        position_info_list = []

        for symbol, pos in self.open_positions.items():
            status, current_price, profit_pct = self.get_position_status(symbol, pos)

            if status is None or "Достигнат TP" in status or "Достигнат SL" in status:
                continue

            # Добавяме информацията за сортиране
            position_info_list.append((symbol, pos, status, current_price, profit_pct))

        # Сортираме позициите по печалба (от най-добра към най-лоша)
        position_info_list.sort(key=lambda x: x[4], reverse=True)

        # Обработваме и добавяме информация за всяка активна позиция
        for symbol, pos, status, current_price, profit_pct in position_info_list:
            # Определяме емотикон според печалба/загуба с по-ясна визуализация
            if profit_pct > 5:
                emoji = "🔥🔥"  # Двоен огън за значителна печалба > 5%
            elif profit_pct > 2:
                emoji = "🔥"    # Огън за печалба > 2%
            elif profit_pct > 0:
                emoji = "🟢"    # Зелено за печалба
            elif profit_pct < -3:
                emoji = "💧💧"  # Двойна капка за значителна загуба > 3%
            elif profit_pct < 0:
                emoji = "🔴"    # Червено за загуба
            else:
                emoji = "⚪"    # Бяло за неутрално

            # Изчисляваме времетраене на позицията ако е налично
            position_duration = ""
            if hasattr(pos, 'open_time'):
                duration = current_time - pos['open_time']
                hours, remainder = divmod(duration.total_seconds(), 3600)
                minutes, _ = divmod(remainder, 60)
                position_duration = f" • ⏱️ {int(hours)}ч {int(minutes)}м"

            # Допълнителна информация за risk:reward
            risk = abs(pos['entry_price'] - pos['sl'])
            reward = abs(pos['tp'] - pos['entry_price'])
            risk_reward = reward / risk if risk > 0 else 0

            # Изчисляваме % на очакван/потенциалeн TP/SL от текущата цена
            if pos['side'] == 'Buy':
                tp_potential = (pos['tp'] - current_price) / current_price * 100
                sl_risk = (current_price - pos['sl']) / current_price * 100
            else:  # Sell
                tp_potential = (current_price - pos['tp']) / current_price * 100
                sl_risk = (pos['sl'] - current_price) / current_price * 100

            # Визуализация на прогреса към TP/SL
            progress_bar = ""
            if "В печалба" in status and "към TP" in status:
                progress_pct = float(status.split(" ")[2].split("%")[0])  # Извличаме процента от статуса
                progress_bar = self.generate_progress_bar(progress_pct, "TP")
            elif "В загуба" in status and "към SL" in status:
                progress_pct = float(status.split(" ")[2].split("%")[0])  # Извличаме процента от статуса
                progress_bar = self.generate_progress_bar(progress_pct, "SL")

            # Добавяме ATR информация, ако е налична
            atr_info = ""
            if 'atr' in pos and pos['atr']:
                atr_pct = pos['atr'] / current_price * 100 if current_price > 0 else 0
                atr_info = f" | ATR: {atr_pct:.2f}%"

            # Подобрена информация за trailing SL
            trailing_sl_info = ""
            if pos.get('trailing_sl_active', False):
                original_sl = pos.get('original_sl', pos['sl'])
                if pos['side'] == 'Buy':
                    protected_profit = (pos['sl'] - original_sl) / pos['entry_price'] * 100 if pos['entry_price'] > 0 else 0
                    sl_move_pct = (pos['sl'] - original_sl) / original_sl * 100 if original_sl > 0 else 0
                else:  # Sell
                    protected_profit = (original_sl - pos['sl']) / pos['entry_price'] * 100 if pos['entry_price'] > 0 else 0
                    sl_move_pct = (original_sl - pos['sl']) / original_sl * 100 if original_sl > 0 else 0

                # Показваме и колко се е преместил SL спрямо началния
                trailing_sl_info = f" | 🛡️ TSL: +{protected_profit:.2f}% (Преместен: {sl_move_pct:.1f}%)"

            # AI прогноза за символа с подобрена визуализация и информация за всички индикатори
            ai_prediction = ""
            if hasattr(self, 'ai_predictor') and symbol in self.ai_predictor.last_predictions:
                pred = self.ai_predictor.last_predictions[symbol]
                trend = pred['trend']
                strength = pred['signal_strength']

                # Подобрено визуализиране на силата на сигнала
                strength_bars = "█" * int(strength * 5)  # Визуализация на силата от 0 до 5 блока
                strength_empty = "░" * (5 - int(strength * 5))
                strength_meter = f"{strength_bars}{strength_empty} {strength:.2f}"

                if trend == 'up':
                    trend_emoji = "🟢⬆️"
                    trend_text = "UP"
                elif trend == 'down':
                    trend_emoji = "🔴⬇️"
                    trend_text = "DOWN"
                else:
                    trend_emoji = "⚪↔️"
                    trend_text = "NEUTRAL"

                # Базова AI прогноза с включване на ML информация, ако е налична
                if 'ml_model' in pred.get('indicators_info', {}):
                    ml_info = pred['indicators_info']['ml_model']
                    ml_trained = ml_info.get('trained', False)
                    ml_probability = ml_info.get('success_probability', 0.5)
                    ml_data_points = ml_info.get('data_points', 0)

                    # Визуализация на ML статуса
                    if ml_trained:
                        ml_status = f"🤖 ML модел активен ({ml_data_points} сделки, {ml_probability:.2f} вероятност)"
                    else:
                        ml_status = f"🤖 ML модел се обучава ({ml_data_points}/5 сделки)"

                    ai_prediction = f"\n   🧠 AI прогноза: {trend_emoji} {trend_text} (сила: {strength_meter})\n   {ml_status}"
                else:
                    ai_prediction = f"\n   🧠 AI прогноза: {trend_emoji} {trend_text} (сила: {strength_meter})"

                # Добавяме информация за индикаторите, ако е налична
                if 'indicators_info' in pred:
                    indicators = pred['indicators_info']

                    # 1. MACD информация
                    if 'macd' in indicators:
                        macd_info = indicators['macd']

                        # Определяме MACD статус
                        macd_status = ""
                        if macd_info.get('macd_bullish_cross', False):
                            macd_status = "🟢 Бичи кръст"
                        elif macd_info.get('macd_bearish_cross', False):
                            macd_status = "🔴 Мечи кръст"
                        elif macd_info.get('macd_line', 0) > macd_info.get('macd_signal', 0):
                            macd_status = "📈 Над сигнала"
                        elif macd_info.get('macd_line', 0) < macd_info.get('macd_signal', 0):
                            macd_status = "📉 Под сигнала"

                        # Добавяме MACD статус към AI прогнозата с подобрена точност и оценка на силата
                        if macd_status:
                            macd_hist = macd_info.get('macd_hist', 0)
                            macd_strength = ""
                            if abs(macd_hist) < 0.000001:
                                macd_strength = "много слаб сигнал"
                            elif abs(macd_hist) < 0.00005:
                                macd_strength = "слаб сигнал"
                            elif abs(macd_hist) < 0.0002:
                                macd_strength = "умерен сигнал"
                            else:
                                macd_strength = "силен сигнал"

                            ai_prediction += f"\n   📊 MACD: {macd_status} (hist: {macd_hist:.8f}, {macd_strength})"

                    # 2. Bollinger Bands информация
                    if 'bollinger' in indicators:
                        bb_info = indicators['bollinger']
                        bb_status = ""

                        if bb_info.get('above_upper', False):
                            bb_status = "🔴 Над горна лента"
                        elif bb_info.get('below_lower', False):
                            bb_status = "🟢 Под долна лента"
                        elif bb_info.get('position', 0.5) < 0.3:
                            bb_status = "🟡 Близо до долна лента"
                        elif bb_info.get('position', 0.5) > 0.7:
                            bb_status = "🟠 Близо до горна лента"
                        else:
                            bb_status = "⚪ В средата на лентите"

                        if bb_info.get('narrowing', False):
                            bb_status += " | Свиване на лентите"

                        ai_prediction += f"\n   📶 Bollinger: {bb_status}"

                    # 3. Fibonacci информация
                    if 'fibonacci' in indicators:
                        fib_info = indicators['fibonacci']
                        fib_status = ""

                        # Определяме в коя зона сме
                        fib_zone = fib_info.get('zone', 3)
                        if fib_zone <= 1:
                            fib_zone_text = "0-23.6%"
                        elif fib_zone == 2:
                            fib_zone_text = "23.6-38.2%"
                        elif fib_zone == 3:
                            fib_zone_text = "38.2-50%"
                        elif fib_zone == 4:
                            fib_zone_text = "50-61.8%"
                        elif fib_zone == 5:
                            fib_zone_text = "61.8-78.6%"
                        else:
                            fib_zone_text = "78.6-100%"

                        fib_status = f"Зона: {fib_zone_text}"

                        # Добавяме отблъсквания
                        if fib_info.get('bounce_from_support', False):
                            fib_status += " | 🟢 Отблъскване от подкрепа"
                        elif fib_info.get('bounce_from_resistance', False):
                            fib_status += " | 🔴 Отблъскване от съпротива"

                        ai_prediction += f"\n   🔱 Fibonacci: {fib_status}"

                    # 4. Stochastic информация
                    if 'stochastic' in indicators:
                        stoch_info = indicators['stochastic']
                        stoch_status = ""

                        if stoch_info.get('bullish_oversold_cross', False):
                            stoch_status = "🟢🟢 Бичи кръст от пренапродадена зона"
                        elif stoch_info.get('bearish_overbought_cross', False):
                            stoch_status = "🔴🔴 Мечи кръст от пренакупена зона"
                        elif stoch_info.get('bullish_cross', False):
                            stoch_status = "🟢 Бичи кръст"
                        elif stoch_info.get('bearish_cross', False):
                            stoch_status = "🔴 Мечи кръст"
                        elif stoch_info.get('overbought', False):
                            stoch_status = "🟠 Пренакупен"
                        elif stoch_info.get('oversold', False):
                            stoch_status = "🟡 Пренапродаден"
                        else:
                            stoch_status = "⚪ Неутрален"

                        ai_prediction += f"\n   🔄 Stochastic: {stoch_status}"

                    # 5. Z-score и Mean Reversion информация
                    # Получаваме features от AI predictor
                    symbol_features = self.ai_predictor.features.get(symbol, {}) if hasattr(self, 'ai_predictor') else {}

                    z_score = symbol_features.get('z_score', 0)
                    price_change_z_score = symbol_features.get('price_change_z_score', 0)
                    is_extreme = symbol_features.get('is_extreme', 0) == 1
                    autocorrelation = symbol_features.get('autocorrelation', 0)
                    distance_from_mean = symbol_features.get('distance_from_mean', 0)
                    mean_reversion_signal = symbol_features.get('mean_reversion_signal', 0) == 1
                    mean_reversion_buy = symbol_features.get('mean_reversion_buy', 0) == 1
                    mean_reversion_sell = symbol_features.get('mean_reversion_sell', 0) == 1

                    # Z-score статус
                    z_score_status = ""
                    if abs(z_score) > 3:
                        z_score_status = "🟣 Екстремно отклонение"
                    elif abs(z_score) > 2:
                        z_score_status = "🔴 Голямо отклонение"
                    elif abs(z_score) > 1:
                        z_score_status = "🟠 Умерено отклонение"
                    else:
                        z_score_status = "🟢 Нормални стойности"

                    z_score_direction = "↗️" if z_score > 0 else "↘️" if z_score < 0 else "➡️"

                    # Mean Reversion статус
                    mr_status = ""
                    if mean_reversion_buy:
                        mr_status = "🟢 MR сигнал за покупка"
                    elif mean_reversion_sell:
                        mr_status = "🔴 MR сигнал за продажба"
                    elif mean_reversion_signal:
                        mr_status = "⚠️ Възможен обрат (mean reversion)"
                    elif autocorrelation > 0.3:
                        mr_status = "➡️ Trend following (автокорелация)"
                    elif autocorrelation < -0.3:
                        mr_status = "↔️ Висока mean reversion тенденция"
                    else:
                        mr_status = "⚪ Неутрален"

                    ai_prediction += f"\n   📊 Z-score: {z_score_status} {z_score_direction} ({z_score:.2f})"
                    ai_prediction += f"\n   🔁 Mean Reversion: {mr_status}"
                # Поддръжка за старата структура с 'macd_info' за обратна съвместимост
                elif 'macd_info' in pred:
                    macd_info = pred['macd_info']

                    # Определяме MACD статус
                    macd_status = ""
                    if macd_info.get('macd_bullish_cross', False):
                        macd_status = "🟢 Бичи кръст"
                    elif macd_info.get('macd_bearish_cross', False):
                        macd_status = "🔴 Мечи кръст"
                    elif macd_info.get('macd_line', 0) > macd_info.get('macd_signal', 0):
                        macd_status = "📈 Над сигнала"
                    elif macd_info.get('macd_line', 0) < macd_info.get('macd_signal', 0):
                        macd_status = "📉 Под сигнала"

                    # Добавяме MACD статус към AI прогнозата
                    if macd_status:
                        ai_prediction += f"\n   📊 MACD: {macd_status} (hist: {macd_info.get('macd_hist', 0):.6f})"

            # Форматиране на печалба/загуба с плюс символ за печалба и подобрена визуализация
            if profit_pct > 0:
                profit_display = f"+{profit_pct:.2f}% 📈"
            else:
                profit_display = f"{profit_pct:.2f}% 📉"

            # Добавяме информация за посоката на сделката с визуални индикатори
            direction_icon = "📈 Buy" if pos['side'] == 'Buy' else "📉 Sell"
            
            # Добавяме информация за мулти-таймфрейм тренда, ако е налична
            mtf_info = ""
            mtf_trend = ""  # Инициализираме mtf_trend с празен стринг по подразбиране
            
            if hasattr(self, 'ai_predictor') and symbol in self.ai_predictor.last_predictions:
                prediction = self.ai_predictor.last_predictions[symbol]
                if 'multi_timeframe' in prediction.get('indicators_info', {}):
                    mtf_data = prediction['indicators_info']['multi_timeframe']
                    mtf_trend = mtf_data.get('trend', 'neutral')
                    mtf_alignment = mtf_data.get('alignment', 0)
                
                    # Избираме подходящи емоджита за MTF тренда
                    if mtf_trend == 'strong_up':
                        mtf_emoji = "🟢🟢"
                    elif mtf_trend == 'up':
                        mtf_emoji = "🟢"
                    elif mtf_trend == 'strong_down':
                        mtf_emoji = "🔴🔴"
                    elif mtf_trend == 'down':
                        mtf_emoji = "🔴"
                    else:
                        mtf_emoji = "⚪"
                    
                    # Добавяме информация за съгласуваността
                    alignment_text = "висока" if mtf_alignment > 0.8 else "средна" if mtf_alignment > 0.5 else "ниска"
                    
                    mtf_info = f"\n   📊 MTF Анализ: {mtf_emoji} {mtf_trend.upper()} (съгласуваност: {alignment_text})"
                    
                    # Добавяме информация за отделните таймфреймове
                    if 'timeframes' in mtf_data:
                        tf_info = []
                        
                        for tf, tf_data in mtf_data['timeframes'].items():
                            tf_trend = tf_data.get('trend', 'neutral')
                            tf_emoji = "🟢" if 'up' in tf_trend else "🔴" if 'down' in tf_trend else "⚪"
                            tf_info.append(f"{tf}: {tf_emoji}")
                        
                        mtf_info += f"\n   🕒 Таймфреймове: {' | '.join(tf_info)}"

            # Добавяме време на отваряне, ако е налично
            entry_time = ""
            if 'open_time' in pos:
                entry_time = f" ({pos['open_time'].strftime('%H:%M')})"

            # Построяваме съобщението с по-добро визуално форматиране
            msg += (f"{emoji} {symbol} {direction_icon}: {status}{position_duration}\n"
                   f"   💵 Текуща цена: {current_price:.6f} (Вход: {pos['entry_price']:.6f}{entry_time})\n"
                   f"   {progress_bar}\n"
                   f"   💹 P&L: {profit_display} | R:R = 1:{risk_reward:.2f}{atr_info}{trailing_sl_info}\n"
                   f"   🎯 TP: {pos['tp']:.6f} (+{tp_potential:.2f}%) | 🛑 SL: {pos['sl']:.6f} (-{sl_risk:.2f}%)"
                   f"{ai_prediction}{mtf_info}\n\n")

        # Изпращаме информацията към логове и Telegram само ако има активни позиции
        if position_info_list:
            logging.info(msg)
            self.send_telegram(msg)
        else:
            logging.info("Няма активни позиции за показване.")

    def generate_progress_bar(self, progress, target_type):
        """Генерира подобрена визуална лента на прогреса към TP или SL с повече детайли."""
        max_bars = 10
        filled_bars = int(progress * max_bars / 100)
        filled_bars = min(filled_bars, max_bars)  # Осигуряваме, че не надвишава макс. стойност

        # Добавяме различни емоджита според прогреса за по-добра визуализация
        if target_type == "TP":
            # За TP използваме различни зелени емоджита според прогреса
            if progress >= 90:
                # Почти достигнат таргет - специален индикатор
                indicator = "🔜 "
                filled = "🟩" * filled_bars
            elif progress >= 70:
                # Много близо до таргет - по-наситени зелени блокове
                indicator = "🚀 "
                filled = "🟩" * filled_bars
            elif progress >= 40:
                # Добър прогрес - стандартни зелени блокове
                indicator = "💹 "
                filled = "🟩" * filled_bars
            else:
                # Начален прогрес - по-светли зелени блокове
                indicator = "🌱 "
                filled = "🟩" * filled_bars

            empty = "⬜" * (max_bars - filled_bars)

            # Добавяме цифрова информация с процент и визуализация
            return f"{indicator}Прогрес към TP: {filled}{empty} {progress:.1f}%"
        else:  # SL
            # За SL използваме различни червени емоджита според прогреса
            if progress >= 90:
                # Почти достигнат SL - критично предупреждение
                indicator = "⚠️ "
                filled = "🟥" * filled_bars
            elif progress >= 70:
                # Близо до SL - по-интензивно предупреждение
                indicator = "🚨 "
                filled = "🟥" * filled_bars
            elif progress >= 40:
                # Значителен прогрес към SL - стандартно предупреждение
                indicator = "⚡ "
                filled = "🟥" * filled_bars
            else:
                # Начален прогрес към SL - леко предупреждение
                indicator = "📉 "
                filled = "🟥" * filled_bars

            empty = "⬜" * (max_bars - filled_bars)

            # Добавяме цифрова информация с процент и визуализация
            return f"{indicator}Прогрес към SL: {filled}{empty} {progress:.1f}%"

    def update_trailing_stop_loss(self, symbol, pos, current_price):
        """
        Актуализира стоп лос нивото на базата на движението на цената за защита на печалбата 
        с динамичен ATR-базиран метод и стъпално проследяване.
        """
        # Основни данни за позицията
        entry_price = pos['entry_price']
        original_sl = pos.get('original_sl', pos['sl'])
        current_sl = pos['sl']
        
        # Получаваме текуща ATR стойност за волатилността на пазара
        atr_value = self._calculate_atr(symbol)
        
        # Проверяваме дали имаме валидна ATR стойност
        if not atr_value or atr_value <= 0:
            # Ако няма валидна стойност, използваме запазената или резервна
            atr_value = pos.get('atr', 0)
            if atr_value <= 0:
                # Резервна стойност - използваме 1% от цената като приблизителна волатилност
                atr_value = entry_price * 0.01
                logging.warning(f"Липсва ATR стойност за {symbol}, използваме 1% от цената: {atr_value:.6f}")
        
        # Обновяваме ATR стойността в позицията за бъдеща употреба
        pos['atr'] = atr_value
        
        # Изчисляваме процент печалба/загуба
        profit_pct = 0.0
        if entry_price > 0:
            if pos['side'] == 'Buy':
                profit_pct = (current_price - entry_price) / entry_price * 100
            else:  # Sell
                profit_pct = (entry_price - current_price) / entry_price * 100

        # Изчисляваме ATR като процент от цената - ключово за измерване на текуща волатилност
        atr_pct = atr_value / current_price * 100 if current_price > 0 else 0
        
        # Записваме волатилността за по-късна справка
        pos['current_volatility'] = atr_pct
        
        # ДИНАМИЧЕН ПРАГ ЗА АКТИВИРАНЕ НА TRAILING STOP LOSS
        # Адаптиране на прага според текущата волатилност на пазара
        if atr_pct > 1.5:  # Висока волатилност
            # При висока волатилност - по-висок праг за активиране на trailing SL
            # за да избегнем преждевременно активиране при нормални колебания
            activation_threshold = max(0.75, atr_pct * 0.6)  # Минимум 0.75% или 60% от ATR
            logging.debug(f"Висока волатилност за {symbol}: {atr_pct:.2f}%, праг за активиране: {activation_threshold:.2f}%")
        elif atr_pct > 0.8:  # Средна волатилност
            activation_threshold = max(0.5, atr_pct * 0.5)   # Минимум 0.5% или 50% от ATR
        else:  # Ниска волатилност
            activation_threshold = max(0.3, atr_pct * 0.4)   # Минимум 0.3% или 40% от ATR
            logging.debug(f"Ниска волатилност за {symbol}: {atr_pct:.2f}%, праг за активиране: {activation_threshold:.2f}%")
        
        # Използваме зададената стойност от конфигурацията или изчислената
        min_activation_threshold = pos.get('trailing_activation_threshold', 0.5)
        profit_threshold = max(min_activation_threshold, activation_threshold)
        
        # Ако вече имаме активен trailing SL, използваме по-нисък праг за продължаване
        if pos.get('trailing_sl_active', False):
            profit_threshold = 0
            
        # Записваме максималната цена постигната в печалба (за проследяване на обрати)
        if 'max_profit_price' not in pos:
            if pos['side'] == 'Buy':
                pos['max_profit_price'] = current_price
            else:  # Sell
                pos['max_profit_price'] = current_price
        else:
            # Обновяваме максималната цена ако позицията е още в печалба
            if pos['side'] == 'Buy' and current_price > pos['max_profit_price']:
                pos['max_profit_price'] = current_price
            elif pos['side'] == 'Sell' and current_price < pos['max_profit_price']:
                pos['max_profit_price'] = current_price

        # Проверяваме дали е време да активираме или преместим trailing SL
        if profit_pct >= profit_threshold:
            # ДИНАМИЧНА ЗАЩИТА НА ПЕЧАЛБАТА СПОРЕД ВОЛАТИЛНОСТТА
            
            # Базовите стойности за защита на печалба
            base_protection = 0.35  # Начална защита 35%
            max_protection = 0.85  # Максимална защита 85%
            
            # Адаптиране на процента защита според волатилността
            if atr_pct > 1.5:  # Много висока волатилност
                # При много висока волатилност, започваме с по-ниска защита
                base_protection = 0.3  # 30% защита при висока волатилност
                # Корекция на кривата на прогресия
                if profit_pct <= 2.5 * atr_pct:
                    # За малки печалби при висока волатилност - бавно покачваме защитата
                    protection_factor = base_protection + (profit_pct / (2.5 * atr_pct)) * 0.2
                elif profit_pct <= 5 * atr_pct:
                    # За средни печалби при висока волатилност
                    protection_factor = 0.5 + (profit_pct - 2.5 * atr_pct) / (2.5 * atr_pct) * 0.2
                else:
                    # За големи печалби при висока волатилност
                    protection_factor = 0.7 + (profit_pct - 5 * atr_pct) / (5 * atr_pct) * 0.15
            elif atr_pct > 0.8:  # Нормална волатилност
                # Стандартна прогресия за нормална волатилност
                if profit_pct <= 2 * atr_pct:
                    # За малки печалби (до 2x ATR) - по-консервативна защита
                    protection_factor = base_protection + (profit_pct / (2 * atr_pct)) * 0.2
                elif profit_pct <= 4 * atr_pct:
                    # За средни печалби (2-4x ATR) - увеличаваме защитата
                    protection_factor = 0.55 + (profit_pct - 2 * atr_pct) / (2 * atr_pct) * 0.15
                else:
                    # За големи печалби (над 4x ATR) - максимална защита
                    protection_factor = 0.7 + (profit_pct - 4 * atr_pct) / (4 * atr_pct) * 0.15
            else:  # Ниска волатилност
                # При ниска волатилност, може да защитим повече печалба
                base_protection = 0.4  # 40% защита при ниска волатилност
                if profit_pct <= 1.5 * atr_pct:
                    # За малки печалби при ниска волатилност - бързо покачваме защитата
                    protection_factor = base_protection + (profit_pct / (1.5 * atr_pct)) * 0.25
                elif profit_pct <= 3 * atr_pct:
                    # За средни печалби при ниска волатилност
                    protection_factor = 0.65 + (profit_pct - 1.5 * atr_pct) / (1.5 * atr_pct) * 0.15
                else:
                    # За големи печалби при ниска волатилност
                    protection_factor = 0.8 + (profit_pct - 3 * atr_pct) / (3 * atr_pct) * 0.05
                
            # Ограничаваме до максималната защита
            protection_factor = min(max_protection, protection_factor)
            
            # Изчисляваме защитената печалба като процент
            protected_profit_pct = profit_pct * protection_factor
            
            # ДИНАМИЧЕН ATR МНОЖИТЕЛ ЗА TRAILING STOP РАЗСТОЯНИЕ
            # Определя колко ATR разстояние да оставяме между текущата цена и стоп лоса
            
            # Базов ATR множител, адаптиран към волатилността
            if atr_pct > 1.5:  # Много висока волатилност
                # При висока волатилност, оставяме по-голямо разстояние
                base_atr_multiplier = 1.5
            elif atr_pct > 0.8:  # Нормална волатилност
                base_atr_multiplier = 1.2
            else:  # Ниска волатилност
                base_atr_multiplier = 1.0
            
            # Финална корекция според размера на печалбата
            if profit_pct > 5 * atr_pct:
                # При много голяма печалба, намаляваме дистанцията на SL
                atr_multiplier = base_atr_multiplier * 0.7
            elif profit_pct > 3 * atr_pct:
                # При голяма печалба
                atr_multiplier = base_atr_multiplier * 0.8
            elif profit_pct > 2 * atr_pct:
                # При средна печалба
                atr_multiplier = base_atr_multiplier * 0.9
            else:
                # При малка печалба, използваме пълния множител
                atr_multiplier = base_atr_multiplier
                
            # Размер на минималната стъпка за преместване на SL - адаптивен според волатилността
            min_move_threshold = max(0.15, atr_pct * 0.15)  # Минимум 0.15% или 15% от ATR%
            
            # Логваме информация за динамичните параметри
            logging.debug(f"Динамичен SL за {symbol}: ATR%={atr_pct:.2f}%, множител={atr_multiplier:.2f}, защита={protection_factor:.2f}, мин.стъпка={min_move_threshold:.2f}%")
            
            # Специфична логика за Buy и Sell позиции
            if pos['side'] == 'Buy':
                # За Buy позиции изчисляваме SL базирано на защитената печалба и ATR
                # SL базирано на защитена печалба
                profit_based_sl = entry_price * (1 + protected_profit_pct / 100)
                
                # Алтернативно SL базирано на ATR дистанция от текущата цена
                atr_based_sl = current_price - (atr_value * atr_multiplier)
                
                # Избираме по-високото от двете за по-добра защита
                new_sl_price = max(profit_based_sl, atr_based_sl)
                
                # Проверка за breakeven - при печалба над ATR-адаптивния праг
                breakeven_threshold = max(1.5, atr_pct * 2)
                if profit_pct >= breakeven_threshold and not pos.get('breakeven_set', False):
                    # Слагаме SL малко над входа
                    min_breakeven_sl = entry_price * 1.001  # 0.1% над входа
                    if current_sl < min_breakeven_sl:
                        new_sl_price = max(new_sl_price, min_breakeven_sl)
                        pos['breakeven_set'] = True
                        logging.info(f"Break-Even SL активиран за {symbol} на ниво {new_sl_price:.6f}")
                
                # Добавяме буфер за избягване на чести промени
                min_move_pct = min_move_threshold  # Използваме изчисления адаптивен праг
                min_sl_move = current_sl * (1 + min_move_pct/100)
                
                # Проверяваме дали новото SL е значително по-високо от текущото
                if new_sl_price > max(current_sl, min_sl_move):
                    # Закръгляме SL според изискванията на символа
                    new_sl_price = self.round_price(symbol, new_sl_price)
                    pos['sl'] = new_sl_price
                    
                    # Проверка за отдалечаване - да не слагаме SL твърде далеч от цената
                    # Адаптивна максимална дистанция според волатилността
                    max_distance = atr_value * max(1.2, min(2.0, base_atr_multiplier * 1.2))
                    if current_price - new_sl_price > max_distance:
                        closer_sl = current_price - max_distance
                        new_sl_price = self.round_price(symbol, closer_sl)
                        pos['sl'] = new_sl_price
                    
                    # Записваме оригиналния SL при първата промяна
                    if 'original_sl' not in pos:
                        pos['original_sl'] = original_sl
                    
                    # Активираме trailing SL
                    pos['trailing_sl_active'] = True
                    
                    # Записваме цената, при която е активиран trailing SL
                    if not pos.get('trailing_activated_price', 0):
                        pos['trailing_activated_price'] = current_price
                    
                    # Записваме защитената печалба
                    pos['protected_profit'] = protected_profit_pct
                    
                    # Записваме информация за логовете
                    sl_move_pct = ((new_sl_price - current_sl) / current_sl * 100) if current_sl > 0 else 0
                    sl_distance_pct = ((current_price - new_sl_price) / current_price * 100) if current_price > 0 else 0
                    
                    # Записваме ATR множителя и волатилността за по-лесно трасиране
                    pos['atr_multiplier'] = atr_multiplier
                    
                    logging.info(f"Trailing SL обновен за {symbol} (Buy). Нов SL: {new_sl_price:.6f} "
                                f"(Промяна: +{sl_move_pct:.2f}%, Дистанция: {sl_distance_pct:.2f}%, "
                                f"Защитена печалба: {protected_profit_pct:.2f}%, ATR множител: {atr_multiplier:.2f}, Волатилност: {atr_pct:.2f}%)")
                    
                    # Изпращаме известие за значителни промени
                    significant_change = False
                    
                    # Изпращаме известие при първа активация
                    if not pos.get('trailing_sl_notified', False):
                        significant_change = True
                        pos['trailing_sl_notified'] = True
                    # Или при голяма промяна в SL (поне 0.5% движение)
                    elif sl_move_pct >= 0.5:
                        significant_change = True
                    # Или ако е минало достатъчно време от последното известие (30 минути)
                    elif (hasattr(self, 'last_sl_update_msg_time') and 
                          symbol in self.last_sl_update_msg_time and 
                          time.time() - self.last_sl_update_msg_time.get(symbol, 0) > 1800):
                        significant_change = True
                    
                    if significant_change:
                        protected_amount = protected_profit_pct * entry_price / 100
                        
                        # Определяме статус на SL
                        if pos.get('breakeven_set', False) and new_sl_price > entry_price:
                            sl_status = "✅ Break-Even активиран (гарантирана печалба)"
                        else:
                            sl_status = f"🔒 Trailing SL активен (защитава {protected_profit_pct:.2f}%)"
                        
                        msg = (f"🛡️ TRAILING STOP LOSS АКТИВИРАН\n\n"
                               f"Символ: {symbol} (Buy)\n"
                               f"Входна цена: {entry_price:.6f}\n"
                               f"Текуща цена: {current_price:.6f} (+{profit_pct:.2f}%)\n"
                               f"Нов стоп лос: {new_sl_price:.6f} (Дистанция: {sl_distance_pct:.2f}%)\n"
                               f"{sl_status}\n"
                               f"ATR: {atr_value:.6f} ({atr_pct:.2f}%), Множител: {atr_multiplier:.2f}\n"
                               f"Защитен профит: ~{protected_amount:.2f} USDT\n"
                               f"Време: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                        self.send_telegram(msg)
                        
                        # Обновяваме времето на последното известие
                        if not hasattr(self, 'last_sl_update_msg_time'):
                            self.last_sl_update_msg_time = {}
                        self.last_sl_update_msg_time[symbol] = time.time()
            
            else:  # Sell
                # За Sell позиции изчисляваме SL базирано на защитената печалба и ATR
                # SL базирано на защитена печалба
                profit_based_sl = entry_price * (1 - protected_profit_pct / 100)
                
                # Алтернативно SL базирано на ATR дистанция от текущата цена
                atr_based_sl = current_price + (atr_value * atr_multiplier)
                
                # Избираме по-ниското от двете за по-добра защита
                new_sl_price = min(profit_based_sl, atr_based_sl)
                
                # Проверка за breakeven - при печалба над ATR-адаптивния праг
                breakeven_threshold = max(1.5, atr_pct * 2)
                if profit_pct >= breakeven_threshold and not pos.get('breakeven_set', False):
                    # Слагаме SL малко под входа
                    min_breakeven_sl = entry_price * 0.999  # 0.1% под входа
                    if current_sl > min_breakeven_sl:
                        new_sl_price = min(new_sl_price, min_breakeven_sl)
                        pos['breakeven_set'] = True
                        logging.info(f"Break-Even SL активиран за {symbol} на ниво {new_sl_price:.6f}")
                
                # Добавяме буфер за избягване на чести промени
                min_move_pct = min_move_threshold  # Използваме изчисления адаптивен праг
                min_sl_move = current_sl * (1 - min_move_pct/100)
                
                # Проверяваме дали новото SL е значително по-ниско от текущото
                if new_sl_price < min(current_sl, min_sl_move):
                    # Закръгляме SL според изискванията на символа
                    new_sl_price = self.round_price(symbol, new_sl_price)
                    pos['sl'] = new_sl_price
                    
                    # Проверка за отдалечаване - да не слагаме SL твърде далеч от цената
                    # Адаптивна максимална дистанция според волатилността
                    max_distance = atr_value * max(1.2, min(2.0, base_atr_multiplier * 1.2))
                    if new_sl_price - current_price > max_distance:
                        closer_sl = current_price + max_distance
                        new_sl_price = self.round_price(symbol, closer_sl)
                        pos['sl'] = new_sl_price
                    
                    # Записваме оригиналния SL при първата промяна
                    if 'original_sl' not in pos:
                        pos['original_sl'] = original_sl
                    
                    # Активираме trailing SL
                    pos['trailing_sl_active'] = True
                    
                    # Записваме цената, при която е активиран trailing SL
                    if not pos.get('trailing_activated_price', 0):
                        pos['trailing_activated_price'] = current_price
                    
                    # Записваме защитената печалба
                    pos['protected_profit'] = protected_profit_pct
                    
                    # Записваме ATR множителя и волатилността за по-лесно трасиране
                    pos['atr_multiplier'] = atr_multiplier
                    
                    # Записваме информация за логовете
                    sl_move_pct = ((current_sl - new_sl_price) / current_sl * 100) if current_sl > 0 else 0
                    sl_distance_pct = ((new_sl_price - current_price) / current_price * 100) if current_price > 0 else 0
                    
                    logging.info(f"Trailing SL обновен за {symbol} (Sell). Нов SL: {new_sl_price:.6f} "
                                f"(Промяна: -{sl_move_pct:.2f}%, Дистанция: {sl_distance_pct:.2f}%, "
                                f"Защитена печалба: {protected_profit_pct:.2f}%, ATR множител: {atr_multiplier:.2f}, Волатилност: {atr_pct:.2f}%)")
                    
                    # Изпращаме известие за значителни промени
                    significant_change = False
                    
                    # Изпращаме известие при първа активация
                    if not pos.get('trailing_sl_notified', False):
                        significant_change = True
                        pos['trailing_sl_notified'] = True
                    # Или при голяма промяна в SL (поне 0.5% движение)
                    elif sl_move_pct >= 0.5:
                        significant_change = True
                    # Или ако е минало достатъчно време от последното известие (30 минути)
                    elif (hasattr(self, 'last_sl_update_msg_time') and 
                          symbol in self.last_sl_update_msg_time and 
                          time.time() - self.last_sl_update_msg_time.get(symbol, 0) > 1800):
                        significant_change = True
                    
                    if significant_change:
                        protected_amount = protected_profit_pct * entry_price / 100
                        
                        # Определяме статус на SL
                        if pos.get('breakeven_set', False) and new_sl_price < entry_price:
                            sl_status = "✅ Break-Even активиран (гарантирана печалба)"
                        else:
                            sl_status = f"🔒 Trailing SL активен (защитава {protected_profit_pct:.2f}%)"
                        
                        msg = (f"🛡️ TRAILING STOP LOSS АКТИВИРАН\n\n"
                               f"Символ: {symbol} (Sell)\n"
                               f"Входна цена: {entry_price:.6f}\n"
                               f"Текуща цена: {current_price:.6f} (+{profit_pct:.2f}%)\n"
                               f"Нов стоп лос: {new_sl_price:.6f} (Дистанция: {sl_distance_pct:.2f}%)\n"
                               f"{sl_status}\n"
                               f"ATR: {atr_value:.6f} ({atr_pct:.2f}%), Множител: {atr_multiplier:.2f}\n"
                               f"Защитен профит: ~{protected_amount:.2f} USDT\n"
                               f"Време: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                        self.send_telegram(msg)
                        
                        # Обновяваме времето на последното известие
                        if not hasattr(self, 'last_sl_update_msg_time'):
                            self.last_sl_update_msg_time = {}
                        self.last_sl_update_msg_time[symbol] = time.time()
        
        # АГРЕСИВНО УПРАВЛЕНИЕ ПРИ ПРОМЯНА НА ТРЕНДА / ВОЛАТИЛНОСТТА
        
        # Проверяваме дали цената е започнала да се движи против нас след достигане на печалба
        if pos.get('trailing_sl_active', False) and 'max_profit_price' in pos:
            # За Buy позиции - проверяваме дали цената се е движила надолу от максимума
            if pos['side'] == 'Buy':
                max_price = pos['max_profit_price']
                # Изчисляваме колко процента цената е паднала от максимума
                price_retracement = (max_price - current_price) / max_price * 100 if max_price > 0 else 0
                
                # Динамичен праг за отстъпление според волатилността
                if atr_pct > 1.5:  # Много висока волатилност
                    # При много висока волатилност - по-голям праг, за да избегнем фалшиви сигнали
                    retracement_threshold = min(1.5, atr_pct * 0.7)  # Използваме 70% от ATR или максимум 1.5%
                elif atr_pct > 0.8:  # Нормална волатилност
                    retracement_threshold = min(1.0, atr_pct * 0.6)  # Използваме 60% от ATR или максимум 1%
                else:  # Ниска волатилност
                    retracement_threshold = min(0.7, atr_pct * 0.5)  # Използваме 50% от ATR или максимум 0.7%
                
                # Активираме агресивен SL при значителен откат от върха
                if price_retracement > retracement_threshold and profit_pct > 1.0:
                    # Изчисляваме по-агресивен SL при обръщане с динамичен буфер
                    atr_buffer = atr_value * min(0.7, max(0.3, atr_pct * 0.1))  # Между 0.3 и 0.7 ATR, адаптирано към волатилността
                    retracement_sl = current_price + atr_buffer
                    
                    # Но не по-ниско от текущия SL
                    if retracement_sl > pos['sl']:
                        # Закръгляме
                        retracement_sl = self.round_price(symbol, retracement_sl)
                        pos['sl'] = retracement_sl
                        
                        logging.info(f"Агресивен Trailing SL активиран за {symbol} (Buy) поради {price_retracement:.2f}% отстъпление от максимума. "
                                     f"Волатилност: {atr_pct:.2f}%, Праг: {retracement_threshold:.2f}%, Буфер: {atr_buffer:.6f}, Нов SL: {retracement_sl:.6f}")
            
            # За Sell позиции - проверяваме дали цената се е движила нагоре от минимума
            else:  # Sell
                min_price = pos['max_profit_price']  # За Sell, това е всъщност минимумът
                # Изчисляваме колко процента цената е пораснала от минимума
                price_retracement = (current_price - min_price) / min_price * 100 if min_price > 0 else 0
                
                # Динамичен праг за отстъпление според волатилността
                if atr_pct > 1.5:  # Много висока волатилност
                    # При много висока волатилност - по-голям праг, за да избегнем фалшиви сигнали
                    retracement_threshold = min(1.5, atr_pct * 0.7)  # Използваме 70% от ATR или максимум 1.5%
                elif atr_pct > 0.8:  # Нормална волатилност
                    retracement_threshold = min(1.0, atr_pct * 0.6)  # Използваме 60% от ATR или максимум 1%
                else:  # Ниска волатилност
                    retracement_threshold = min(0.7, atr_pct * 0.5)  # Използваме 50% от ATR или максимум 0.7%
                
                # Активираме агресивен SL при значителен откат от върха
                if price_retracement > retracement_threshold and profit_pct > 1.0:
                    # Изчисляваме по-агресивен SL при обръщане с динамичен буфер
                    atr_buffer = atr_value * min(0.7, max(0.3, atr_pct * 0.1))  # Между 0.3 и 0.7 ATR, адаптирано към волатилността
                    retracement_sl = current_price - atr_buffer
                    
                    # Но не по-високо от текущия SL
                    if retracement_sl < pos['sl']:
                        # Закръгляме
                        retracement_sl = self.round_price(symbol, retracement_sl)
                        pos['sl'] = retracement_sl
                        
                        logging.info(f"Агресивен Trailing SL активиран за {symbol} (Sell) поради {price_retracement:.2f}% отстъпление от минимума. "
                                     f"Волатилност: {atr_pct:.2f}%, Праг: {retracement_threshold:.2f}%, Буфер: {atr_buffer:.6f}, Нов SL: {retracement_sl:.6f}")

        # УПРАВЛЕНИЕ ПРИ ВНЕЗАПНА ПРОМЯНА НА ВОЛАТИЛНОСТТА
        # Ако волатилността се е увеличила значително, може да коригираме SL
        
        if pos.get('trailing_sl_active', False) and 'prev_volatility' in pos:
            prev_volatility = pos['prev_volatility']
            volatility_increase = (atr_pct - prev_volatility) / prev_volatility if prev_volatility > 0 else 0
            
            # Ако волатилността се е увеличила с над 50%, коригираме SL за избягване на преждевременно активиране
            if volatility_increase > 0.5 and atr_pct > 1.0:
                if pos['side'] == 'Buy':
                    # Изчисляваме нов SL с по-голяма дистанция поради увеличената волатилност
                    safer_sl = current_price - (atr_value * 1.5)  # Използваме по-голям множител при увеличена волатилност
                    
                    # Коригираме SL само ако текущият е твърде близо до цената според новата волатилност
                    if pos['sl'] > safer_sl:
                        pos['sl'] = self.round_price(symbol, safer_sl)
                        logging.info(f"SL коригиран поради увеличена волатилност за {symbol} (Buy). Нов SL: {safer_sl:.6f}, "
                                     f"Увеличение на волатилността: {volatility_increase*100:.2f}%, ATR%: {atr_pct:.2f}%")
                else:  # Sell
                    # Изчисляваме нов SL с по-голяма дистанция поради увеличената волатилност
                    safer_sl = current_price + (atr_value * 1.5)  # Използваме по-голям множител при увеличена волатилност
                    
                    # Коригираме SL само ако текущият е твърде близо до цената според новата волатилност
                    if pos['sl'] < safer_sl:
                        pos['sl'] = self.round_price(symbol, safer_sl)
                        logging.info(f"SL коригиран поради увеличена волатилност за {symbol} (Sell). Нов SL: {safer_sl:.6f}, "
                                     f"Увеличение на волатилността: {volatility_increase*100:.2f}%, ATR%: {atr_pct:.2f}%")
        
        # Запазваме текущата волатилност за следващата итерация
        pos['prev_volatility'] = atr_pct

        return pos

    def check_positions(self):
        """Проверява отворените позиции за промени (дали са затворени от TP/SL) и актуализира trailing stop loss."""
        # Показваме информация за текущите позиции
        if self.open_positions:
            self.display_open_positions()

        # В тестов режим, проверяваме дали реалните цени са достигнали TP или SL
        if self.test_mode:
            for symbol, pos in list(self.open_positions.items()):
                # Проверяваме текущия статус на позицията
                status, current_price, profit_pct = self.get_position_status(symbol, pos)

                if current_price is None:
                    continue

                # Актуализираме trailing SL при печалба
                self.open_positions[symbol] = self.update_trailing_stop_loss(symbol, pos, current_price)

                # Вземаме актуализираните данни след потенциалните промени в trailing SL
                pos = self.open_positions[symbol]
                closed_side = pos['side']
                entry_price = pos['entry_price']
                tp = pos['tp']
                sl = pos['sl']

                # Проверка дали реално е достигнат TP или SL
                outcome = None
                exit_price = None

                # За Buy позиции
                if closed_side == 'Buy':
                    if current_price >= tp:  # Достигнат Take Profit
                        outcome = "TP"
                        exit_price = tp
                    elif current_price <= sl:  # Достигнат Stop Loss
                        outcome = "SL"
                        exit_price = sl
                # За Sell позиции        
                else:  # Sell
                    if current_price <= tp:  # Достигнат Take Profit
                        outcome = "TP"
                        exit_price = tp
                    elif current_price >= sl:  # Достигнат Stop Loss
                        outcome = "SL"
                        exit_price = sl

                # Ако е достигнат TP или SL, затваряме позицията
                if outcome:
                    # Изчисляваме процент печалба/загуба
                    profit_pct = 0.0
                    if entry_price > 0:
                        if closed_side == 'Buy':
                            profit_pct = (exit_price - entry_price) / entry_price * 100
                        else:  # Sell
                            profit_pct = (entry_price - exit_price) / entry_price * 100

                    # Добавяме емоджи според резултата
                    if outcome == "TP":
                        emoji = "✅"
                        outcome_text = "ТАРГЕТ ПОСТИГНАТ"
                    else:
                        emoji = "❌"
                        outcome_text = "СТОП ДОСТИГНАТ"

                    # Добавяме информация за trailing SL, ако е бил активен
                    trailing_info = ""
                    if pos.get('trailing_sl_active', False) and outcome == "SL":
                        original_sl = pos.get('original_sl', sl)
                        if closed_side == 'Buy':
                            protected_profit = (sl - original_sl) / entry_price * 100
                        else:  # Sell
                            protected_profit = (original_sl - sl) / entry_price * 100

                        if protected_profit > 0:
                            trailing_info = f"\nДвижещият се SL защити {protected_profit:.2f}% печалба"

                    profit_emoji = "🟢" if profit_pct > 0 else "🔴"
                    profit_text = f"+{profit_pct:.2f}%" if profit_pct > 0 else f"{profit_pct:.2f}%"

                    msg = (f"{emoji} {outcome_text} - TEST MODE {emoji}\n\n"
                           f"{profit_emoji} Симулирана {closed_side} позиция на {symbol} приключена\n"
                           f"Изходна цена: {exit_price:.4f} (Вход: {entry_price:.4f})\n"
                           f"P&L: {profit_text}{trailing_info}\n"
                           f"Време: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                    logging.info(msg)
                    self.send_telegram(msg)

                    # Записваме резултата за обучение на AI модела, ако моделът поддържа тази функция
                    if hasattr(self.ai_predictor, 'record_trade_result'):
                        # Проверяваме дали позицията е била отворена с AI сигнал
                        if hasattr(self, 'signal_log'):
                            # Търсим сигнала за тази позиция
                            for log in self.signal_log:
                                if log['symbol'] == symbol and log['signal'] == closed_side:
                                    # Извличаме features ако са били запазени
                                    features = self.ai_predictor.features.get(symbol)
                                    if features:
                                        self.ai_predictor.record_trade_result(
                                            symbol=symbol,
                                            features=features,
                                            signal=closed_side,
                                            outcome=outcome,
                                            profit_pct=profit_pct
                                        )
                                        logging.info(f"Записан резултат от сделка за {symbol} за обучение на ML модела")
                                    break

                    # Премахваме позицията от отворените
                    self.open_positions.pop(symbol, None)
            return

        # Real trading mode position checks
        for symbol, pos in list(self.open_positions.items()):
            # Определяме правилната категория за символа
            category = 'linear'
            if 'PERP' in symbol:
                category = 'inverse'
                logging.info(f"Проверка на позиция за {symbol} в категория 'inverse'")

            try:
                # Опитваме се да вземем позицията със съответната категория
                pos_data = self.session.get_positions(category=category, symbol=symbol)

                # Ако има грешка с категорията, пробваме другата
                if pos_data.get('retCode') != 0 and category == 'linear':
                    logging.info(f"Позицията не е намерена в linear категория, пробваме inverse за {symbol}")
                    category = 'inverse'
                    pos_data = self.session.get_positions(category=category, symbol=symbol)
                elif pos_data.get('retCode') != 0 and category == 'inverse':
                    logging.info(f"Позицията не е намерена в inverse категория, пробваме linear за {symbol}")
                    category = 'linear'
                    pos_data = self.session.get_positions(category=category, symbol=symbol)

            except Exception as e:
                logging.error(f"Грешка при проверка на позиция за {symbol}: {e}")
                continue

            if pos_data.get('retCode') == 0:
                positions = pos_data['result']['list']
                # Ако позицията все още е отворена, актуализираме trailing SL
                position_still_open = False
                current_price = None

                for p in positions:
                    # Проверяваме дали има размер на позицията
                    position_size = 0
                    try:
                        position_size = float(p.get('size', 0))
                    except (ValueError, TypeError):
                        try:
                            position_size = float(p.get('qty', 0))
                        except (ValueError, TypeError):
                            position_size = 0

                    if position_size > 0:
                        position_still_open = True
                        # Опитваме да вземем текущата цена за актуализиране на trailing SL
                        try:
                            tick = self.session.get_tickers(category=category, symbol=symbol)
                            if tick.get('retCode') == 0 and tick['result']['list']:
                                current_price = float(tick['result']['list'][0]['lastPrice'])

                                # Актуализираме trailing SL при наличие на печалба
                                self.open_positions[symbol] = self.update_trailing_stop_loss(symbol, pos, current_price)

                                # Ако SL е променен и сме в реален режим (не test_mode), обновяваме стоп лоса в Bybit
                                if pos.get('trailing_sl_active', False) and not self.test_mode:
                                    try:
                                        # Изпълняваме set_trading_stop заявка за обновяване на SL
                                        new_sl = str(self.open_positions[symbol]['sl'])
                                        
                                        # Вземаме текущия SL, за да избегнем ненужни обновявания
                                        try:
                                            position_info = self.session.get_positions(
                                                category=category,
                                                symbol=symbol
                                            )
                                            
                                            if position_info.get('retCode') == 0 and position_info['result']['list']:
                                                pos_data = position_info['result']['list'][0]
                                                current_sl = pos_data.get('stopLoss', '0')
                                                
                                                # Проверяваме дали новият SL е достатъчно различен от текущия
                                                # За да избегнем "not modified" грешки
                                                if abs(float(new_sl) - float(current_sl)) / float(current_price) < 0.001:
                                                    # Разлика по-малка от 0.1% - пропускаме обновяването
                                                    logging.info(f"Пропуснато обновяване на SL за {symbol}: новият SL {new_sl} е твърде близо до текущия {current_sl}")
                                                    continue
                                        except Exception as e:
                                            # Ако не можем да вземем позицията, ще опитаме да обновим SL директно
                                            logging.warning(f"Не може да се провери текущия SL за {symbol}: {e}")
                                        
                                        # Изпращаме заявката за обновяване на SL
                                        resp = self.session.set_trading_stop(
                                            category=category,
                                            symbol=symbol,
                                            stopLoss=new_sl,
                                            positionIdx=0  # За едностранна (хеджирана) позиция индексът е 0
                                        )

                                        if resp.get('retCode') != 0:
                                            error_msg = resp.get('retMsg', 'Неизвестна грешка')
                                            error_code = resp.get('retCode', 0)
                                            
                                            # Специфична обработка на грешката "not modified" (34040)
                                            if error_code == 34040:
                                                logging.info(f"SL за {symbol} не е променен (вероятно извън позволения диапазон или без промяна)")
                                                # Запазваме оригиналната позиция за SL
                                                self.open_positions[symbol]['sl'] = float(current_sl) if 'current_sl' in locals() else pos['sl']
                                            else:
                                                logging.error(f"Грешка при обновяване на SL за {symbol}: {error_msg} (код: {error_code})")
                                            
                                                # Опитваме без positionIdx при грешка за позиционния индекс
                                                if "position idx not exists" in error_msg.lower():
                                                    resp = self.session.set_trading_stop(
                                                        category=category,
                                                        symbol=symbol,
                                                        stopLoss=new_sl
                                                    )
                                                    if resp.get('retCode') == 0:
                                                        logging.info(f"Успешно обновен SL за {symbol} без positionIdx")
                                    except Exception as e:
                                        logging.error(f"Изключение при обновяване на SL за {symbol}: {e}")
                        except Exception as e:
                            logging.error(f"Грешка при взимане на цена за trailing SL на {symbol}: {e}")
                        break

                # Ако позицията е затворена
                if not position_still_open:
                    closed_side = pos['side']
                    entry_price = pos['entry_price']
                    tp = pos['tp']
                    sl = pos['sl']

                    # Опитваме да вземем текущата последна цена (приблизителна цена на затваряне)
                    exit_price = None
                    try:
                        tick = self.session.get_tickers(category=category, symbol=symbol)
                        if tick.get('retCode') == 0 and tick['result']['list']:
                            exit_price = float(tick['result']['list'][0]['lastPrice'])
                    except Exception:
                        pass

                    if exit_price is None:
                        try:
                            # Пробваме със заявка към публичния API
                            resp = requests.get(f"{self.base_url}/v5/market/tickers?category={category}&symbol={symbol}", timeout=5)
                            data = resp.json()
                            if data.get('retCode') == 0 and data.get('result', {}).get('list'):
                                exit_price = float(data['result']['list'][0]['lastPrice'])
                        except Exception:
                            pass

                    # Ако все още нямаме цена, пробваме с другата категория
                    if exit_price is None:
                        try:
                            alt_category = 'linear' if category == 'inverse' else 'inverse'
                            resp = requests.get(f"{self.base_url}/v5/market/tickers?category={alt_category}&symbol={symbol}", timeout=5)
                            data = resp.json()
                            if data.get('retCode') == 0 and data.get('result', {}).get('list'):
                                exit_price = float(data['result']['list'][0]['lastPrice'])
                        except Exception:
                            exit_price = None

                    # Определяме на око дали TP или SL е достигнато (на база коя цел е по-близка до крайната цена)
                    if exit_price is not None:
                        outcome = "TP" if abs(exit_price - tp) < abs(exit_price - sl) else "SL"

                        # Calculate profit/loss percentage
                        profit_pct = 0.0
                        if entry_price > 0:
                            if closed_side == 'Buy':
                                profit_pct = (exit_price - entry_price) / entry_price * 100
                            else:  # Sell
                                profit_pct = (entry_price - exit_price) / entry_price * 100

                        # Подобрена визуализация със специални емоджита и форматиране
                        if outcome == "TP":
                            emoji = "✅"
                            outcome_text = "ТАРГЕТ ПОСТИГНАТ"
                        else:
                            emoji = "❌"
                            outcome_text = "СТОП ДОСТИГНАТ"

                        # Добавяме информация за trailing SL, ако е бил активен
                        trailing_info = ""
                        if pos.get('trailing_sl_active', False) and outcome == "SL":
                            original_sl = pos.get('original_sl', sl)
                            if closed_side == 'Buy':
                                protected_profit = (sl - original_sl) / entry_price * 100
                            else:  # Sell
                                protected_profit = (original_sl - sl) / entry_price * 100

                            if protected_profit > 0:
                                trailing_info = f"\nДвижещият се SL защити {protected_profit:.2f}% печалба"

                        profit_emoji = "🟢" if profit_pct > 0 else "🔴"
                        profit_text = f"+{profit_pct:.2f}%" if profit_pct > 0 else f"{profit_pct:.2f}%"
                    else:
                        outcome = "затворена"
                        emoji = "⚪"
                        outcome_text = "ПОЗИЦИЯ ЗАТВОРЕНА"
                        profit_emoji = "⚪"
                        profit_text = "неизвестно"
                        trailing_info = ""

                    # Добавяме информация за времетраенето на позицията, ако е налично
                    position_duration = ""
                    if 'open_time' in pos:
                        duration = datetime.now() - pos['open_time']
                        hours, remainder = divmod(duration.total_seconds(), 3600)
                        minutes, seconds = divmod(remainder, 60)
                        position_duration = f"\nПродължителност: {int(hours)}ч {int(minutes)}м"

                    msg = (f"{emoji} {outcome_text} {emoji}\n\n"
                           f"{profit_emoji} {closed_side} позиция на {symbol} приключена\n"
                           f"Изходна цена: {exit_price:.4f} (Вход: {entry_price:.4f}){position_duration}\n"
                           f"P&L: {profit_text}{trailing_info}\n"
                           f"Време: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                    logging.info(msg)
                    self.send_telegram(msg)

                    # Записваме резултата за обучение на AI модела 
                    if hasattr(self.ai_predictor, 'record_trade_result'):
                        # Проверяваме дали позицията е била отворена с AI сигнал
                        if hasattr(self, 'signal_log'):
                            # Търсим сигнала за тази позиция
                            for log in self.signal_log:
                                if log['symbol'] == symbol and log['signal'] == closed_side:
                                    # Извличаме features ако са били запазени
                                    features = self.ai_predictor.features.get(symbol)
                                    if features:
                                        self.ai_predictor.record_trade_result(
                                            symbol=symbol,
                                            features=features,
                                            signal=closed_side,
                                            outcome=outcome,
                                            profit_pct=profit_pct
                                        )
                                        logging.info(f"Записан резултат от сделка за {symbol} за обучение на ML модела. Общо {len(self.ai_predictor.trade_history)} сделки.")
                                    break
                        else:
                            # Дори и да нямаме точен сигнал, пак записваме сделката за обучение
                            features = self.ai_predictor.features.get(symbol)
                            if features:
                                self.ai_predictor.record_trade_result(
                                    symbol=symbol,
                                    features=features,
                                    signal=closed_side,
                                    outcome=outcome,
                                    profit_pct=profit_pct
                                )
                                logging.info(f"Записан общ резултат от сделка за {symbol}. Общо {len(self.ai_predictor.trade_history)} сделки.")

                    # Премахваме символа от списъка с отворени позиции
                    self.open_positions.pop(symbol, None)
            else:
                # Логваме грешката, но не премахваме позицията, защото може да е проблем с API или с категорията
                logging.warning(f"Неуспешно извличане на позиция за {symbol} в категория {category}: {pos_data.get('retMsg')}")

    def send_telegram(self, message):
        """Изпраща съобщение в Telegram с подадения текст."""
        if not self.telegram_token or not self.telegram_chat_id:
            return
        try:
            url = f"https://api.telegram.org/bot{self.telegram_token}/sendMessage"
            payload = {'chat_id': self.telegram_chat_id, 'text': message}
            requests.post(url, json=payload, timeout=5)
        except Exception as e:
            logging.error(f"Неуспешно Telegram известие: {e}")

    def run(self):
        """Стартира основния цикъл на търговия на бота с AI анализ."""
        logging.info("Starting trading loop with AI analysis...")

        # Инициализираме буфер между проверките на различните символи
        if not hasattr(self, 'last_checked'):
            self.last_checked = {}

        # Максимален брой едновременно отворени позиции
        max_open_positions = 5  # Ограничаваме до 5 отворени позиции едновременно
        
        # Адаптивно управление на API заявките
        if not hasattr(self, 'api_errors_count'):
            self.api_errors_count = 0
        
        if not hasattr(self, 'symbol_batch_size'):
            self.symbol_batch_size = 20  # Начален размер на пакета с проверявани символи
        
        if not hasattr(self, 'last_api_error_time'):
            self.last_api_error_time = 0

        while True:
            current_time = time.time()
            
            # Адаптивно намаляване на batch размера при API грешки
            if self.api_errors_count > 5 and current_time - self.last_api_error_time < 1800:  # Грешки в последните 30 минути
                self.symbol_batch_size = max(5, self.symbol_batch_size // 2)  # Намаляваме на половина, но не по-малко от 5
                logging.warning(f"Намален batch размер до {self.symbol_batch_size} символа поради API грешки")
                self.api_errors_count = 0
            elif current_time - self.last_api_error_time > 3600:  # Ако е минал час без грешки
                # Постепенно увеличаваме batch размера
                self.symbol_batch_size = min(20, self.symbol_batch_size + 2)
                self.api_errors_count = 0

            # Проверяваме дали не сме достигнали лимита на отворени позиции
            if len(self.open_positions) >= max_open_positions:
                logging.info(f"Достигнат лимит на отворени позиции ({max_open_positions}). Изчакване позиция да приключи.")

                # Продължаваме да проверяваме отворените позиции
                self.check_positions()
                time.sleep(300)  # Изчакваме 5 минути преди следваща проверка
                continue

            # Проверяваме символите на пакети за избягване на API ограничения
            total_symbols = len(self.all_symbols)
            batch_size = self.symbol_batch_size
            
            logging.info(f"Проверка на общо {total_symbols} символа (размер на пакета: {batch_size})...")

            # Пазим сигналите с най-висока вероятност за успех
            potential_signals = []
            
            # Филтрираме символи, на които вече имаме позиции
            available_symbols = [s for s in self.all_symbols if s not in self.open_positions]
            
            # Работим на пакети от по batch_size символа
            for i in range(0, len(available_symbols), batch_size):
                # Вземаме текущия пакет
                current_batch = available_symbols[i:i+batch_size]
                logging.info(f"Обработка на пакет {i//batch_size + 1}/{(len(available_symbols) + batch_size - 1)//batch_size}: {len(current_batch)} символа")
                
                # Обработваме символите от текущия пакет
                for symbol in current_batch:
                    try:
                        # Изтегляме данни и анализираме за сигнал
                        data = self.fetch_market_data(symbol)

                        # Пропускаме символи без достатъчно данни
                        if not data or not data.get('candles') or len(data.get('candles', [])) < 30:
                            continue

                        # Генерираме AI features за модела
                        features = self.ai_predictor.generate_features(symbol, data.get('candles', []), data.get('trades', []))

                        # Получаваме AI прогноза за движението
                        prediction = None
                        if features:
                            prediction = self.ai_predictor.predict_movement(symbol, features)

                        # Получаваме технически сигнал от analyze_market
                        signal = self.analyze_market(symbol, data)

                        # Записваме времето на последна проверка
                        self.last_checked[symbol] = current_time

                        # Добавяме повече логове за анализ
                        if signal:
                            logging.info(f"Технически сигнал за {symbol}: {signal}")
                        elif features and prediction and prediction['signal_strength'] > 0.4:
                            logging.info(f"Има AI предсказание за {symbol} с тренд {prediction['trend']} и сила {prediction['signal_strength']:.2f}, но липсва технически сигнал")

                        # Оценяваме качеството на сигнала с AI прогнозата
                        signal_quality = 0.0

                        if signal and prediction:
                            # Проверка за несъответствие между ML и техническия анализ
                            ml_success_probability = prediction.get('indicators_info', {}).get('ml_model', {}).get('success_probability', 0.5)
                            ml_confidence_signal = "up" if ml_success_probability > 0.65 else "down" if ml_success_probability < 0.35 else "neutral"
                            rules_trend = prediction.get('trend', 'neutral')
                            
                            # Логваме информация за ML модела и техническия анализ
                            logging.info(f"ML предсказание за {symbol}: {ml_success_probability:.2f}, технически тренд: {rules_trend}, сигнал: {signal}")
                            
                            # Проверяваме противоречие между ML и техническия анализ
                            contradiction = (ml_confidence_signal == "up" and rules_trend == "down") or \
                                          (ml_confidence_signal == "down" and rules_trend == "up") or \
                                          (ml_confidence_signal == "up" and signal == "Sell") or \
                                          (ml_confidence_signal == "down" and signal == "Buy")
                            
                            if contradiction:
                                logging.warning(f"Несъответствие между ML ({ml_confidence_signal}) и технически анализ ({rules_trend}). Игнориране на сигнала за {symbol}.")
                                continue
                            
                            # Проверяваме дали техническият сигнал съвпада с AI прогнозата
                            if (signal == 'Buy' and prediction['trend'] == 'up') or (signal == 'Sell' and prediction['trend'] == 'down'):
                                # Сигналът е потвърден от AI - увеличаваме quality score с 10%
                                signal_quality = min(0.9, prediction['signal_strength'] * 1.1)
                                
                                # Увеличаваме допълнително quality ако имаме потвърждение от ML
                                if (signal == 'Buy' and ml_confidence_signal == "up") or (signal == 'Sell' and ml_confidence_signal == "down"):
                                    signal_quality = min(0.95, signal_quality * 1.15)
                                    logging.info(f"Троен сигнал за {symbol}: технически, AI тренд и ML модел съвпадат")

                                # Запазваме сигнала с детайли за по-късно оценяване
                                potential_signals.append({
                                    'symbol': symbol,
                                    'signal': signal,
                                    'quality': signal_quality,
                                    'prediction': prediction,
                                    'ml_confidence': ml_success_probability
                                })
                                logging.info(f"Found potential {signal} signal for {symbol} with quality {signal_quality:.2f}")
                    except Exception as e:
                        logging.error(f"Грешка при обработка на символ {symbol}: {e}")
                        self.api_errors_count += 1
                        self.last_api_error_time = current_time
                
                # Малка пауза между пакетите за избягване на rate limit
                if i + batch_size < len(available_symbols):
                    time.sleep(1)

            # Избираме най-качествените сигнали, ако имаме такива
            if potential_signals:
                # Сортираме по качество (от най-високо към най-ниско)
                potential_signals.sort(key=lambda x: x['quality'], reverse=True)

                # Брой сигнали, които ще изпълним (максимум 2 за цикъл)
                max_signals_per_cycle = min(2, max_open_positions - len(self.open_positions))

                # Изпълняваме само най-качествените сигнали
                for i in range(min(max_signals_per_cycle, len(potential_signals))):
                    signal_info = potential_signals[i]
                    symbol = signal_info['symbol']
                    signal = signal_info['signal']
                    quality = signal_info['quality']

                    # Проверяваме отново дали имаме място за нова позиция
                    if len(self.open_positions) >= max_open_positions:
                        logging.info("Достигнат лимит на отворени позиции при проверка на сигнали.")
                        break

                    # Изпълняваме сделка само ако качеството е достатъчно високо
                    # Адаптивен праг за качеството - изискваме поне 40% ако имаме ML резултат
                    min_quality_threshold = 0.4 if signal_info.get('ml_confidence', 0) > 0 else 0.35
                    if quality >= min_quality_threshold:  # Минимален праг за качество
                        logging.info(f"Executing high-quality {signal} signal for {symbol} (quality: {quality:.2f})")

                        # Избираме стратегия за изпълнение според размера и волатилността
                        strategy = "market"  # По подразбиране - стандартна пазарна поръчка

                        try:
                            # Оценка на размера на търговията
                            self.update_balance()
                            position_value = self.balance * self.risk_percent

                            # Вземаме текущата цена
                            resp = requests.get(f"{self.base_url}/v5/market/tickers?category=linear&symbol={symbol}", timeout=5)
                            data = resp.json()
                            if data.get('retCode') == 0 and data.get('result', {}).get('list'):
                                price = float(data['result']['list'][0]['lastPrice'])

                                # Изчисляваме приблизително количество
                                qty = position_value / price

                                # Получаваме дневния обем
                                resp = requests.get(f"{self.base_url}/v5/market/tickers?category=linear&symbol={symbol}", timeout=5)
                                volume_data = resp.json()
                                if volume_data.get('retCode') == 0 and volume_data.get('result', {}).get('list'):
                                    # Volume data is available in ticker info
                                    volume_24h = float(volume_data['result']['list'][0].get('volume24h', 0))
                                    turnover_24h = float(volume_data['result']['list'][0].get('turnover24h', 0))

                                    # Оценяваме волатилността от ATR
                                    atr_value = self._calculate_atr(symbol)
                                    atr_pct = (atr_value / price * 100) if atr_value and price > 0 else 0

                                    # Избираме стратегия според размера, ликвидността и волатилността
                                    if position_value > 1000 or (position_value > 500 and volume_24h > 0 and position_value / turnover_24h > 0.02):
                                        # Голяма позиция или значителен % от дневния обем - използваме Iceberg
                                        strategy = "iceberg"
                                    elif atr_pct > 1.5 and position_value > 300:
                                        # Висока волатилност - използваме TWAP за по-стабилно изпълнение
                                        strategy = "twap"
                                    elif volume_24h > 1000000 and position_value > 400:
                                        # Висока ликвидност но значителен размер - използваме VWAP
                                        strategy = "vwap"

                                    logging.info(f"Избрана стратегия {strategy} за {symbol}: размер=${position_value:.2f}, волатилност={atr_pct:.2f}%, обем={volume_24h:.0f}")
                        except Exception as e:
                            logging.error(f"Грешка при избор на стратегия: {e}")
                            strategy = "market"

                        # Изпълняваме сделката със съответната стратегия
                        if strategy == "iceberg":
                            self.execute_smart_order(symbol, signal, "iceberg")
                        elif strategy == "twap":
                            self.execute_smart_order(symbol, signal, "twap")
                        elif strategy == "vwap":
                            self.execute_smart_order(symbol, signal, "vwap")
                        else:
                            # Стандартна пазарна поръчка
                            self.execute_trade(symbol, signal)

                        # Изпращаме известие за оставащите свободни позиции и качеството на сигнала след успешно изпълнение
                        # Проверка дали символът е успешно добавен в open_positions
                        if symbol in self.open_positions:
                            remaining_slots = max_open_positions - len(self.open_positions)
                            self.send_telegram(f"ℹ️ Изпълнен {signal} сигнал за {symbol} (качество: {quality:.2f})\nОставащи слотове за позиции: {remaining_slots}/{max_open_positions}")
                        else:
                            self.send_telegram(f"⚠️ Грешка при изпълнение на {signal} сигнал за {symbol} - проверете логовете за повече информация")

                        # Ако сме достигнали лимита, прекратяваме цикъла
                        if len(self.open_positions) >= max_open_positions:
                            break

            # Проверяваме дали някоя отворена позиция е приключила (TP или SL)
            # Това вече съдържа извикване на display_open_positions() в началото
            self.check_positions()

            # Изчакваме 5 минути между циклите
            logging.info("Completed symbol check cycle with AI analysis. Waiting 5 minutes before next cycle...")
            time.sleep(300)  # 300 секунди = 5 минути

# Използване на бота:
# Заменете със собствените API ключове и Telegram данни
# Текущите ключове са невалидни или непълни
# For test mode, you can use Bybit testnet API keys from https://testnet.bybit.com/app/user/api-management
# These are dummy keys for demonstration purposes only
import os

# Вземаме API ключовете от Secrets на Replit
API_KEY = os.environ.get("BYBIT_API_KEY", "IWTzFKpjr2wXBrzlyT")
API_SECRET = os.environ.get("BYBIT_API_SECRET", "BXJmWwzgxaUZKx0IViwgJno0HriBdTmOg2d6")
TELEGRAM_TOKEN = os.environ.get("TELEGRAM_TOKEN", "7636652269:AAGF39Uh8U_B9O11aBhUy2-n1mU_SPk1h1U")
TELEGRAM_CHAT_ID = os.environ.get("TELEGRAM_CHAT_ID", "1335857033")

# Set this to False to use real trading 
TEST_MODE = False

if __name__ == "__main__":
    bot = BybitTradingBot(API_KEY, API_SECRET, TELEGRAM_TOKEN, TELEGRAM_CHAT_ID, test_mode=TEST_MODE)
    bot.run()


# ==========================
# LSTM ПРЕДСКАЗВАЩ МОДЕЛ
# ==========================
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from sklearn.preprocessing import MinMaxScaler
import numpy as np

class LSTMPredictor:
    def __init__(self):
        self.model = self.build_model()
        self.scaler = MinMaxScaler(feature_range=(0, 1))

    def build_model(self):
        model = Sequential([
            LSTM(50, return_sequences=True, input_shape=(10, 1)),
            LSTM(50),
            Dense(1, activation='sigmoid')
        ])
        model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
        return model

    def train(self, data, labels):
        scaled_data = self.scaler.fit_transform(np.array(data).reshape(-1, 1))
        self.model.fit(np.array(scaled_data).reshape(-1, 10, 1), np.array(labels), epochs=10, batch_size=1, verbose=0)

    def predict(self, data):
        scaled_data = self.scaler.transform(np.array(data).reshape(-1, 1))
        prediction = self.model.predict(np.array(scaled_data).reshape(-1, 10, 1))
        return prediction[0][0]

# ==========================
# АДАПТИВНО УПРАВЛЕНИЕ НА РИСКА
# ==========================
class AdaptiveRiskManager:
    def __init__(self):
        self.loss_streak = 0
        self.risk_per_trade = 0.02  # Начално 2%

    def adjust_risk(self):
        if self.loss_streak >= 3:
            self.risk_per_trade = 0.01  # Намалява риска до 1%
        else:
            self.risk_per_trade = 0.02

    def update_loss_streak(self, trade_was_successful):
        if trade_was_successful:
            self.loss_streak = 0
        else:
            self.loss_streak += 1

# ==========================
# ДИНАМИЧЕН TRAILING STOP
# ==========================
class TrailingStopManager:
    def calculate_trailing_stop(self, entry_price, atr):
        return entry_price - atr * 1.5

# ==========================
# АНАЛИЗ НА ЛИКВИДНОСТ И SLIPPAGE
# ==========================
class LiquidityAnalyzer:
    def analyze_liquidity(self, bid_ask_spread):
        if bid_ask_spread > 0.5:  # Ако спредът е прекалено голям, избягваме сделка
            return False
        return True
